"**********************************************************************************
*                           The License						                                      *
* 										                                                                  *
* The user is free to produce commercial applications with the software, to 	          *
* distribute these applications in source or binary  form, and to charge monies         *
* for them as he sees fit and in concordance with the laws of the land subject 	        *
* to the following license.							                                                *
*										                                                                    * 
* 1. The license applies to all the software and all derived software and 	            *
*    must appear on such.							                                                  *
*										                                                                    *
* 2. It is illegal to distribute the software without this license attached	            *
*    to it and use of the software implies agreement with the license as such.          *
*    It is illegal for anyone who is not the copyright holder to tamper with 	          *
*    or change the license.							                                                *
*										                                                                    *
* 3. Neither the names of Lambda Associates or the copyright holder may be used         *
*    to endorse or promote products built using the software without specific 	        *
*    prior written permission from the copyright holder.		                            *
*										                                                                    *
* 4. That possession of this license does not confer on the copyright holder 	          *
*    any special contractual obligation towards the user. That in no event 	            * 
*    shall the copyright holder be liable for any direct, indirect, incidental,        *   
*    special, exemplary or consequential damages (including but not limited             *
*    to procurement of substitute goods or services, loss of use, data, 	              * 
*    interruption), however caused and on any theory of liability, whether in	          * 
*    contract, strict liability or tort (including negligence) arising in any         	*
*    way out of the use of the software, even if advised of the possibility of         	*
*    such damage.						                                                        		* 
*										                                                                    *
* 5. It is permitted for the user to change the software, for the purpose of 	          *
*    improving performance, correcting an error, or porting to a new platform, 	        *
*    and distribute the derived version of Shen provided the resulting program 	        *
*    conforms in all respects to the Shen standard and is issued under that             * 
*    title. The user must make it clear with his distribution that he/she is 	          *
*    the author of the changes and what these changes are and why. 		                  *
*										                                                                    *
* 6. Derived versions of this software in whatever form are subject to the same         *
*    restrictions. In particular it is not permitted to make derived copies of          *
*    this software which do not conform to the Shen standard or appear under a          *
*    different title.								                                                    *
*										                                                                    *
*    It is permitted to distribute versions of Shen which incorporate libraries,        *
*    graphics or other facilities which are not part of the Shen standard.	            *
*										                                                                    *
* For an explication of this license see www.shenlanguage.org/license.htm which         *
* explains this license in full.                                                        *
*				 						                                                                    *
*****************************************************************************************
"(defun shen.typecheck (V2754 V2755) (let Curry (shen.curry V2754) (let ProcessN (shen.start-new-prolog-process) (let Type (shen.insert-prolog-variables (shen.normalise-type (shen.curry-type V2755)) ProcessN) (let Continuation (freeze (return Type ProcessN shen.void)) (shen.t* (cons Curry (cons : (cons Type ()))) () ProcessN Continuation))))))

(defun shen.curry (V2756) (cond ((and (cons? V2756) (shen.special? (hd V2756))) (cons (hd V2756) (map shen.curry (tl V2756)))) ((and (cons? V2756) (and (cons? (tl V2756)) (shen.extraspecial? (hd V2756)))) V2756) ((and (cons? V2756) (and (cons? (tl V2756)) (cons? (tl (tl V2756))))) (shen.curry (cons (cons (hd V2756) (cons (hd (tl V2756)) ())) (tl (tl V2756))))) ((and (cons? V2756) (and (cons? (tl V2756)) (= () (tl (tl V2756))))) (cons (shen.curry (hd V2756)) (cons (shen.curry (hd (tl V2756))) ()))) (true V2756)))

(defun shen.special? (V2757) (element? V2757 (value shen.*special*)))

(defun shen.extraspecial? (V2758) (element? V2758 (value shen.*extraspecial*)))

(defun shen.t* (V2759 V2760 V2761 V2762) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let Error (shen.newpv V2761) (do (shen.incinfs) (fwhen (shen.maxinfexceeded?) V2761 (freeze (bind Error (shen.errormaxinfs) V2761 V2762))))) (if (= Case false) (let Case (let V2748 (shen.lazyderef V2759 V2761) (if (= fail V2748) (do (shen.incinfs) (cut Throwcontrol V2761 (freeze (shen.prolog-failure V2761 V2762)))) false)) (if (= Case false) (let Case (let V2749 (shen.lazyderef V2759 V2761) (if (cons? V2749) (let X (hd V2749) (let V2750 (shen.lazyderef (tl V2749) V2761) (if (cons? V2750) (let V2751 (shen.lazyderef (hd V2750) V2761) (if (= : V2751) (let V2752 (shen.lazyderef (tl V2750) V2761) (if (cons? V2752) (let A (hd V2752) (let V2753 (shen.lazyderef (tl V2752) V2761) (if (= () V2753) (do (shen.incinfs) (fwhen (shen.type-theory-enabled?) V2761 (freeze (cut Throwcontrol V2761 (freeze (shen.th* X A V2760 V2761 V2762)))))) false))) false)) false)) false))) false)) (if (= Case false) (let Datatypes (shen.newpv V2761) (do (shen.incinfs) (shen.show V2759 V2760 V2761 (freeze (bind Datatypes (value shen.*datatypes*) V2761 (freeze (shen.udefs* V2759 V2760 Datatypes V2761 V2762))))))) Case)) Case)) Case)))))

(defun shen.type-theory-enabled? () (value shen.*shen-type-theory-enabled?*))

(defun enable-type-theory (V2767) (cond ((= + V2767) (set shen.*shen-type-theory-enabled?* true)) ((= - V2767) (set shen.*shen-type-theory-enabled?* false)) (true (simple-error "enable-type-theory expects a + or a -
"))))

(defun shen.prolog-failure (V2776 V2777) false)

(defun shen.maxinfexceeded? () (> (inferences) (value shen.*maxinferences*)))

(defun shen.errormaxinfs () (simple-error "maximum inferences exceeded~%"))

(defun shen.udefs* (V2778 V2779 V2780 V2781 V2782) (let Case (let V2744 (shen.lazyderef V2780 V2781) (if (cons? V2744) (let D (hd V2744) (do (shen.incinfs) (call (cons D (cons V2778 (cons V2779 ()))) V2781 V2782))) false)) (if (= Case false) (let V2745 (shen.lazyderef V2780 V2781) (if (cons? V2745) (let Ds (tl V2745) (do (shen.incinfs) (shen.udefs* V2778 V2779 Ds V2781 V2782))) false)) Case)))

(defun shen.th* (V2783 V2784 V2785 V2786 V2787) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (do (shen.incinfs) (shen.show (cons V2783 (cons : (cons V2784 ()))) V2785 V2786 (freeze (fwhen false V2786 V2787)))) (if (= Case false) (let Case (let F (shen.newpv V2786) (do (shen.incinfs) (fwhen (shen.typedf? (shen.lazyderef V2783 V2786)) V2786 (freeze (bind F (shen.sigf (shen.lazyderef V2783 V2786)) V2786 (freeze (call (cons F (cons V2784 ())) V2786 V2787))))))) (if (= Case false) (let Case (do (shen.incinfs) (shen.base V2783 V2784 V2786 V2787)) (if (= Case false) (let Case (do (shen.incinfs) (shen.by_hypothesis V2783 V2784 V2785 V2786 V2787)) (if (= Case false) (let Case (let V2624 (shen.lazyderef V2783 V2786) (if (cons? V2624) (let F (hd V2624) (let V2625 (shen.lazyderef (tl V2624) V2786) (if (= () V2625) (do (shen.incinfs) (shen.th* F (cons --> (cons V2784 ())) V2785 V2786 V2787)) false))) false)) (if (= Case false) (let Case (let V2626 (shen.lazyderef V2783 V2786) (if (cons? V2626) (let F (hd V2626) (let V2627 (shen.lazyderef (tl V2626) V2786) (if (cons? V2627) (let X (hd V2627) (let V2628 (shen.lazyderef (tl V2627) V2786) (if (= () V2628) (let B (shen.newpv V2786) (do (shen.incinfs) (shen.th* F (cons B (cons --> (cons V2784 ()))) V2785 V2786 (freeze (shen.th* X B V2785 V2786 V2787))))) false))) false))) false)) (if (= Case false) (let Case (let V2629 (shen.lazyderef V2783 V2786) (if (cons? V2629) (let V2630 (shen.lazyderef (hd V2629) V2786) (if (= cons V2630) (let V2631 (shen.lazyderef (tl V2629) V2786) (if (cons? V2631) (let X (hd V2631) (let V2632 (shen.lazyderef (tl V2631) V2786) (if (cons? V2632) (let Y (hd V2632) (let V2633 (shen.lazyderef (tl V2632) V2786) (if (= () V2633) (let V2634 (shen.lazyderef V2784 V2786) (if (cons? V2634) (let V2635 (shen.lazyderef (hd V2634) V2786) (if (= list V2635) (let V2636 (shen.lazyderef (tl V2634) V2786) (if (cons? V2636) (let A (hd V2636) (let V2637 (shen.lazyderef (tl V2636) V2786) (if (= () V2637) (do (shen.incinfs) (shen.th* X A V2785 V2786 (freeze (shen.th* Y (cons list (cons A ())) V2785 V2786 V2787)))) (if (shen.pvar? V2637) (do (shen.bindv V2637 () V2786) (let Result (do (shen.incinfs) (shen.th* X A V2785 V2786 (freeze (shen.th* Y (cons list (cons A ())) V2785 V2786 V2787)))) (do (shen.unbindv V2637 V2786) Result))) false)))) (if (shen.pvar? V2636) (let A (shen.newpv V2786) (do (shen.bindv V2636 (cons A ()) V2786) (let Result (do (shen.incinfs) (shen.th* X A V2785 V2786 (freeze (shen.th* Y (cons list (cons A ())) V2785 V2786 V2787)))) (do (shen.unbindv V2636 V2786) Result)))) false))) (if (shen.pvar? V2635) (do (shen.bindv V2635 list V2786) (let Result (let V2638 (shen.lazyderef (tl V2634) V2786) (if (cons? V2638) (let A (hd V2638) (let V2639 (shen.lazyderef (tl V2638) V2786) (if (= () V2639) (do (shen.incinfs) (shen.th* X A V2785 V2786 (freeze (shen.th* Y (cons list (cons A ())) V2785 V2786 V2787)))) (if (shen.pvar? V2639) (do (shen.bindv V2639 () V2786) (let Result (do (shen.incinfs) (shen.th* X A V2785 V2786 (freeze (shen.th* Y (cons list (cons A ())) V2785 V2786 V2787)))) (do (shen.unbindv V2639 V2786) Result))) false)))) (if (shen.pvar? V2638) (let A (shen.newpv V2786) (do (shen.bindv V2638 (cons A ()) V2786) (let Result (do (shen.incinfs) (shen.th* X A V2785 V2786 (freeze (shen.th* Y (cons list (cons A ())) V2785 V2786 V2787)))) (do (shen.unbindv V2638 V2786) Result)))) false))) (do (shen.unbindv V2635 V2786) Result))) false))) (if (shen.pvar? V2634) (let A (shen.newpv V2786) (do (shen.bindv V2634 (cons list (cons A ())) V2786) (let Result (do (shen.incinfs) (shen.th* X A V2785 V2786 (freeze (shen.th* Y (cons list (cons A ())) V2785 V2786 V2787)))) (do (shen.unbindv V2634 V2786) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2640 (shen.lazyderef V2783 V2786) (if (cons? V2640) (let V2641 (shen.lazyderef (hd V2640) V2786) (if (= @p V2641) (let V2642 (shen.lazyderef (tl V2640) V2786) (if (cons? V2642) (let X (hd V2642) (let V2643 (shen.lazyderef (tl V2642) V2786) (if (cons? V2643) (let Y (hd V2643) (let V2644 (shen.lazyderef (tl V2643) V2786) (if (= () V2644) (let V2645 (shen.lazyderef V2784 V2786) (if (cons? V2645) (let A (hd V2645) (let V2646 (shen.lazyderef (tl V2645) V2786) (if (cons? V2646) (let V2647 (shen.lazyderef (hd V2646) V2786) (if (= * V2647) (let V2648 (shen.lazyderef (tl V2646) V2786) (if (cons? V2648) (let B (hd V2648) (let V2649 (shen.lazyderef (tl V2648) V2786) (if (= () V2649) (do (shen.incinfs) (shen.th* X A V2785 V2786 (freeze (shen.th* Y B V2785 V2786 V2787)))) (if (shen.pvar? V2649) (do (shen.bindv V2649 () V2786) (let Result (do (shen.incinfs) (shen.th* X A V2785 V2786 (freeze (shen.th* Y B V2785 V2786 V2787)))) (do (shen.unbindv V2649 V2786) Result))) false)))) (if (shen.pvar? V2648) (let B (shen.newpv V2786) (do (shen.bindv V2648 (cons B ()) V2786) (let Result (do (shen.incinfs) (shen.th* X A V2785 V2786 (freeze (shen.th* Y B V2785 V2786 V2787)))) (do (shen.unbindv V2648 V2786) Result)))) false))) (if (shen.pvar? V2647) (do (shen.bindv V2647 * V2786) (let Result (let V2650 (shen.lazyderef (tl V2646) V2786) (if (cons? V2650) (let B (hd V2650) (let V2651 (shen.lazyderef (tl V2650) V2786) (if (= () V2651) (do (shen.incinfs) (shen.th* X A V2785 V2786 (freeze (shen.th* Y B V2785 V2786 V2787)))) (if (shen.pvar? V2651) (do (shen.bindv V2651 () V2786) (let Result (do (shen.incinfs) (shen.th* X A V2785 V2786 (freeze (shen.th* Y B V2785 V2786 V2787)))) (do (shen.unbindv V2651 V2786) Result))) false)))) (if (shen.pvar? V2650) (let B (shen.newpv V2786) (do (shen.bindv V2650 (cons B ()) V2786) (let Result (do (shen.incinfs) (shen.th* X A V2785 V2786 (freeze (shen.th* Y B V2785 V2786 V2787)))) (do (shen.unbindv V2650 V2786) Result)))) false))) (do (shen.unbindv V2647 V2786) Result))) false))) (if (shen.pvar? V2646) (let B (shen.newpv V2786) (do (shen.bindv V2646 (cons * (cons B ())) V2786) (let Result (do (shen.incinfs) (shen.th* X A V2785 V2786 (freeze (shen.th* Y B V2785 V2786 V2787)))) (do (shen.unbindv V2646 V2786) Result)))) false)))) (if (shen.pvar? V2645) (let A (shen.newpv V2786) (let B (shen.newpv V2786) (do (shen.bindv V2645 (cons A (cons * (cons B ()))) V2786) (let Result (do (shen.incinfs) (shen.th* X A V2785 V2786 (freeze (shen.th* Y B V2785 V2786 V2787)))) (do (shen.unbindv V2645 V2786) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2652 (shen.lazyderef V2783 V2786) (if (cons? V2652) (let V2653 (shen.lazyderef (hd V2652) V2786) (if (= @v V2653) (let V2654 (shen.lazyderef (tl V2652) V2786) (if (cons? V2654) (let X (hd V2654) (let V2655 (shen.lazyderef (tl V2654) V2786) (if (cons? V2655) (let Y (hd V2655) (let V2656 (shen.lazyderef (tl V2655) V2786) (if (= () V2656) (let V2657 (shen.lazyderef V2784 V2786) (if (cons? V2657) (let V2658 (shen.lazyderef (hd V2657) V2786) (if (= vector V2658) (let V2659 (shen.lazyderef (tl V2657) V2786) (if (cons? V2659) (let A (hd V2659) (let V2660 (shen.lazyderef (tl V2659) V2786) (if (= () V2660) (do (shen.incinfs) (shen.th* X A V2785 V2786 (freeze (shen.th* Y (cons vector (cons A ())) V2785 V2786 V2787)))) (if (shen.pvar? V2660) (do (shen.bindv V2660 () V2786) (let Result (do (shen.incinfs) (shen.th* X A V2785 V2786 (freeze (shen.th* Y (cons vector (cons A ())) V2785 V2786 V2787)))) (do (shen.unbindv V2660 V2786) Result))) false)))) (if (shen.pvar? V2659) (let A (shen.newpv V2786) (do (shen.bindv V2659 (cons A ()) V2786) (let Result (do (shen.incinfs) (shen.th* X A V2785 V2786 (freeze (shen.th* Y (cons vector (cons A ())) V2785 V2786 V2787)))) (do (shen.unbindv V2659 V2786) Result)))) false))) (if (shen.pvar? V2658) (do (shen.bindv V2658 vector V2786) (let Result (let V2661 (shen.lazyderef (tl V2657) V2786) (if (cons? V2661) (let A (hd V2661) (let V2662 (shen.lazyderef (tl V2661) V2786) (if (= () V2662) (do (shen.incinfs) (shen.th* X A V2785 V2786 (freeze (shen.th* Y (cons vector (cons A ())) V2785 V2786 V2787)))) (if (shen.pvar? V2662) (do (shen.bindv V2662 () V2786) (let Result (do (shen.incinfs) (shen.th* X A V2785 V2786 (freeze (shen.th* Y (cons vector (cons A ())) V2785 V2786 V2787)))) (do (shen.unbindv V2662 V2786) Result))) false)))) (if (shen.pvar? V2661) (let A (shen.newpv V2786) (do (shen.bindv V2661 (cons A ()) V2786) (let Result (do (shen.incinfs) (shen.th* X A V2785 V2786 (freeze (shen.th* Y (cons vector (cons A ())) V2785 V2786 V2787)))) (do (shen.unbindv V2661 V2786) Result)))) false))) (do (shen.unbindv V2658 V2786) Result))) false))) (if (shen.pvar? V2657) (let A (shen.newpv V2786) (do (shen.bindv V2657 (cons vector (cons A ())) V2786) (let Result (do (shen.incinfs) (shen.th* X A V2785 V2786 (freeze (shen.th* Y (cons vector (cons A ())) V2785 V2786 V2787)))) (do (shen.unbindv V2657 V2786) Result)))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2663 (shen.lazyderef V2783 V2786) (if (cons? V2663) (let V2664 (shen.lazyderef (hd V2663) V2786) (if (= @s V2664) (let V2665 (shen.lazyderef (tl V2663) V2786) (if (cons? V2665) (let X (hd V2665) (let V2666 (shen.lazyderef (tl V2665) V2786) (if (cons? V2666) (let Y (hd V2666) (let V2667 (shen.lazyderef (tl V2666) V2786) (if (= () V2667) (let V2668 (shen.lazyderef V2784 V2786) (if (= string V2668) (do (shen.incinfs) (shen.th* X string V2785 V2786 (freeze (shen.th* Y string V2785 V2786 V2787)))) (if (shen.pvar? V2668) (do (shen.bindv V2668 string V2786) (let Result (do (shen.incinfs) (shen.th* X string V2785 V2786 (freeze (shen.th* Y string V2785 V2786 V2787)))) (do (shen.unbindv V2668 V2786) Result))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2669 (shen.lazyderef V2783 V2786) (if (cons? V2669) (let V2670 (shen.lazyderef (hd V2669) V2786) (if (= lambda V2670) (let V2671 (shen.lazyderef (tl V2669) V2786) (if (cons? V2671) (let X (hd V2671) (let V2672 (shen.lazyderef (tl V2671) V2786) (if (cons? V2672) (let Y (hd V2672) (let V2673 (shen.lazyderef (tl V2672) V2786) (if (= () V2673) (let V2674 (shen.lazyderef V2784 V2786) (if (cons? V2674) (let A (hd V2674) (let V2675 (shen.lazyderef (tl V2674) V2786) (if (cons? V2675) (let V2676 (shen.lazyderef (hd V2675) V2786) (if (= --> V2676) (let V2677 (shen.lazyderef (tl V2675) V2786) (if (cons? V2677) (let B (hd V2677) (let V2678 (shen.lazyderef (tl V2677) V2786) (if (= () V2678) (let Z (shen.newpv V2786) (let X&& (shen.newpv V2786) (do (shen.incinfs) (cut Throwcontrol V2786 (freeze (bind X&& (shen.placeholder) V2786 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2786) (shen.lazyderef X V2786) (shen.lazyderef Y V2786)) V2786 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2785) V2786 V2787)))))))))) (if (shen.pvar? V2678) (do (shen.bindv V2678 () V2786) (let Result (let Z (shen.newpv V2786) (let X&& (shen.newpv V2786) (do (shen.incinfs) (cut Throwcontrol V2786 (freeze (bind X&& (shen.placeholder) V2786 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2786) (shen.lazyderef X V2786) (shen.lazyderef Y V2786)) V2786 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2785) V2786 V2787)))))))))) (do (shen.unbindv V2678 V2786) Result))) false)))) (if (shen.pvar? V2677) (let B (shen.newpv V2786) (do (shen.bindv V2677 (cons B ()) V2786) (let Result (let Z (shen.newpv V2786) (let X&& (shen.newpv V2786) (do (shen.incinfs) (cut Throwcontrol V2786 (freeze (bind X&& (shen.placeholder) V2786 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2786) (shen.lazyderef X V2786) (shen.lazyderef Y V2786)) V2786 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2785) V2786 V2787)))))))))) (do (shen.unbindv V2677 V2786) Result)))) false))) (if (shen.pvar? V2676) (do (shen.bindv V2676 --> V2786) (let Result (let V2679 (shen.lazyderef (tl V2675) V2786) (if (cons? V2679) (let B (hd V2679) (let V2680 (shen.lazyderef (tl V2679) V2786) (if (= () V2680) (let Z (shen.newpv V2786) (let X&& (shen.newpv V2786) (do (shen.incinfs) (cut Throwcontrol V2786 (freeze (bind X&& (shen.placeholder) V2786 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2786) (shen.lazyderef X V2786) (shen.lazyderef Y V2786)) V2786 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2785) V2786 V2787)))))))))) (if (shen.pvar? V2680) (do (shen.bindv V2680 () V2786) (let Result (let Z (shen.newpv V2786) (let X&& (shen.newpv V2786) (do (shen.incinfs) (cut Throwcontrol V2786 (freeze (bind X&& (shen.placeholder) V2786 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2786) (shen.lazyderef X V2786) (shen.lazyderef Y V2786)) V2786 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2785) V2786 V2787)))))))))) (do (shen.unbindv V2680 V2786) Result))) false)))) (if (shen.pvar? V2679) (let B (shen.newpv V2786) (do (shen.bindv V2679 (cons B ()) V2786) (let Result (let Z (shen.newpv V2786) (let X&& (shen.newpv V2786) (do (shen.incinfs) (cut Throwcontrol V2786 (freeze (bind X&& (shen.placeholder) V2786 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2786) (shen.lazyderef X V2786) (shen.lazyderef Y V2786)) V2786 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2785) V2786 V2787)))))))))) (do (shen.unbindv V2679 V2786) Result)))) false))) (do (shen.unbindv V2676 V2786) Result))) false))) (if (shen.pvar? V2675) (let B (shen.newpv V2786) (do (shen.bindv V2675 (cons --> (cons B ())) V2786) (let Result (let Z (shen.newpv V2786) (let X&& (shen.newpv V2786) (do (shen.incinfs) (cut Throwcontrol V2786 (freeze (bind X&& (shen.placeholder) V2786 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2786) (shen.lazyderef X V2786) (shen.lazyderef Y V2786)) V2786 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2785) V2786 V2787)))))))))) (do (shen.unbindv V2675 V2786) Result)))) false)))) (if (shen.pvar? V2674) (let A (shen.newpv V2786) (let B (shen.newpv V2786) (do (shen.bindv V2674 (cons A (cons --> (cons B ()))) V2786) (let Result (let Z (shen.newpv V2786) (let X&& (shen.newpv V2786) (do (shen.incinfs) (cut Throwcontrol V2786 (freeze (bind X&& (shen.placeholder) V2786 (freeze (bind Z (shen.ebr (shen.lazyderef X&& V2786) (shen.lazyderef X V2786) (shen.lazyderef Y V2786)) V2786 (freeze (shen.th* Z B (cons (cons X&& (cons : (cons A ()))) V2785) V2786 V2787)))))))))) (do (shen.unbindv V2674 V2786) Result))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2681 (shen.lazyderef V2783 V2786) (if (cons? V2681) (let V2682 (shen.lazyderef (hd V2681) V2786) (if (= let V2682) (let V2683 (shen.lazyderef (tl V2681) V2786) (if (cons? V2683) (let X (hd V2683) (let V2684 (shen.lazyderef (tl V2683) V2786) (if (cons? V2684) (let Y (hd V2684) (let V2685 (shen.lazyderef (tl V2684) V2786) (if (cons? V2685) (let Z (hd V2685) (let V2686 (shen.lazyderef (tl V2685) V2786) (if (= () V2686) (let W (shen.newpv V2786) (let X&& (shen.newpv V2786) (let B (shen.newpv V2786) (do (shen.incinfs) (cut Throwcontrol V2786 (freeze (shen.th* Y B V2785 V2786 (freeze (bind X&& (shen.placeholder) V2786 (freeze (bind W (shen.ebr (shen.lazyderef X&& V2786) (shen.lazyderef X V2786) (shen.lazyderef Z V2786)) V2786 (freeze (shen.th* W V2784 (cons (cons X&& (cons : (cons B ()))) V2785) V2786 V2787))))))))))))) false))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2687 (shen.lazyderef V2783 V2786) (if (cons? V2687) (let V2688 (shen.lazyderef (hd V2687) V2786) (if (= open V2688) (let V2689 (shen.lazyderef (tl V2687) V2786) (if (cons? V2689) (let V2690 (shen.lazyderef (hd V2689) V2786) (if (= file V2690) (let V2691 (shen.lazyderef (tl V2689) V2786) (if (cons? V2691) (let FileName (hd V2691) (let V2692 (shen.lazyderef (tl V2691) V2786) (if (cons? V2692) (let Direction2620 (hd V2692) (let V2693 (shen.lazyderef (tl V2692) V2786) (if (= () V2693) (let V2694 (shen.lazyderef V2784 V2786) (if (cons? V2694) (let V2695 (shen.lazyderef (hd V2694) V2786) (if (= stream V2695) (let V2696 (shen.lazyderef (tl V2694) V2786) (if (cons? V2696) (let Direction (hd V2696) (let V2697 (shen.lazyderef (tl V2696) V2786) (if (= () V2697) (do (shen.incinfs) (unify! Direction Direction2620 V2786 (freeze (cut Throwcontrol V2786 (freeze (shen.th* FileName string V2785 V2786 V2787)))))) (if (shen.pvar? V2697) (do (shen.bindv V2697 () V2786) (let Result (do (shen.incinfs) (unify! Direction Direction2620 V2786 (freeze (cut Throwcontrol V2786 (freeze (shen.th* FileName string V2785 V2786 V2787)))))) (do (shen.unbindv V2697 V2786) Result))) false)))) (if (shen.pvar? V2696) (let Direction (shen.newpv V2786) (do (shen.bindv V2696 (cons Direction ()) V2786) (let Result (do (shen.incinfs) (unify! Direction Direction2620 V2786 (freeze (cut Throwcontrol V2786 (freeze (shen.th* FileName string V2785 V2786 V2787)))))) (do (shen.unbindv V2696 V2786) Result)))) false))) (if (shen.pvar? V2695) (do (shen.bindv V2695 stream V2786) (let Result (let V2698 (shen.lazyderef (tl V2694) V2786) (if (cons? V2698) (let Direction (hd V2698) (let V2699 (shen.lazyderef (tl V2698) V2786) (if (= () V2699) (do (shen.incinfs) (unify! Direction Direction2620 V2786 (freeze (cut Throwcontrol V2786 (freeze (shen.th* FileName string V2785 V2786 V2787)))))) (if (shen.pvar? V2699) (do (shen.bindv V2699 () V2786) (let Result (do (shen.incinfs) (unify! Direction Direction2620 V2786 (freeze (cut Throwcontrol V2786 (freeze (shen.th* FileName string V2785 V2786 V2787)))))) (do (shen.unbindv V2699 V2786) Result))) false)))) (if (shen.pvar? V2698) (let Direction (shen.newpv V2786) (do (shen.bindv V2698 (cons Direction ()) V2786) (let Result (do (shen.incinfs) (unify! Direction Direction2620 V2786 (freeze (cut Throwcontrol V2786 (freeze (shen.th* FileName string V2785 V2786 V2787)))))) (do (shen.unbindv V2698 V2786) Result)))) false))) (do (shen.unbindv V2695 V2786) Result))) false))) (if (shen.pvar? V2694) (let Direction (shen.newpv V2786) (do (shen.bindv V2694 (cons stream (cons Direction ())) V2786) (let Result (do (shen.incinfs) (unify! Direction Direction2620 V2786 (freeze (cut Throwcontrol V2786 (freeze (shen.th* FileName string V2785 V2786 V2787)))))) (do (shen.unbindv V2694 V2786) Result)))) false))) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2700 (shen.lazyderef V2783 V2786) (if (cons? V2700) (let V2701 (shen.lazyderef (hd V2700) V2786) (if (= type V2701) (let V2702 (shen.lazyderef (tl V2700) V2786) (if (cons? V2702) (let X (hd V2702) (let V2703 (shen.lazyderef (tl V2702) V2786) (if (cons? V2703) (let A (hd V2703) (let V2704 (shen.lazyderef (tl V2703) V2786) (if (= () V2704) (do (shen.incinfs) (cut Throwcontrol V2786 (freeze (unify A V2784 V2786 (freeze (shen.th* X A V2785 V2786 V2787)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2705 (shen.lazyderef V2783 V2786) (if (cons? V2705) (let V2706 (shen.lazyderef (hd V2705) V2786) (if (= input+ V2706) (let V2707 (shen.lazyderef (tl V2705) V2786) (if (cons? V2707) (let V2708 (shen.lazyderef (hd V2707) V2786) (if (= : V2708) (let V2709 (shen.lazyderef (tl V2707) V2786) (if (cons? V2709) (let A (hd V2709) (let V2710 (shen.lazyderef (tl V2709) V2786) (if (= () V2710) (let C (shen.newpv V2786) (do (shen.incinfs) (bind C (shen.normalise-type (shen.lazyderef A V2786)) V2786 (freeze (unify V2784 C V2786 V2787))))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2711 (shen.lazyderef V2783 V2786) (if (cons? V2711) (let V2712 (shen.lazyderef (hd V2711) V2786) (if (= where V2712) (let V2713 (shen.lazyderef (tl V2711) V2786) (if (cons? V2713) (let P (hd V2713) (let V2714 (shen.lazyderef (tl V2713) V2786) (if (cons? V2714) (let X (hd V2714) (let V2715 (shen.lazyderef (tl V2714) V2786) (if (= () V2715) (do (shen.incinfs) (cut Throwcontrol V2786 (freeze (shen.th* P boolean V2785 V2786 (freeze (cut Throwcontrol V2786 (freeze (shen.th* X V2784 (cons (cons P (cons : (cons verified ()))) V2785) V2786 V2787)))))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2716 (shen.lazyderef V2783 V2786) (if (cons? V2716) (let V2717 (shen.lazyderef (hd V2716) V2786) (if (= set V2717) (let V2718 (shen.lazyderef (tl V2716) V2786) (if (cons? V2718) (let Var (hd V2718) (let V2719 (shen.lazyderef (tl V2718) V2786) (if (cons? V2719) (let Val (hd V2719) (let V2720 (shen.lazyderef (tl V2719) V2786) (if (= () V2720) (do (shen.incinfs) (cut Throwcontrol V2786 (freeze (shen.th* (cons value (cons Var ())) V2784 V2785 V2786 (freeze (shen.th* Val V2784 V2785 V2786 V2787)))))) false))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2721 (shen.lazyderef V2783 V2786) (if (cons? V2721) (let V2722 (shen.lazyderef (hd V2721) V2786) (if (= shen.<-sem V2722) (let V2723 (shen.lazyderef (tl V2721) V2786) (if (cons? V2723) (let F (hd V2723) (let V2724 (shen.lazyderef (tl V2723) V2786) (if (= () V2724) (let A (shen.newpv V2786) (let F&& (shen.newpv V2786) (let B (shen.newpv V2786) (do (shen.incinfs) (cut Throwcontrol V2786 (freeze (shen.th* F (cons A (cons ==> (cons B ()))) V2785 V2786 (freeze (cut Throwcontrol V2786 (freeze (bind F&& (concat && (shen.lazyderef F V2786)) V2786 (freeze (cut Throwcontrol V2786 (freeze (shen.th* F&& V2784 (cons (cons F&& (cons : (cons B ()))) V2785) V2786 V2787))))))))))))))) false))) false)) false)) false)) (if (= Case false) (let Case (let V2725 (shen.lazyderef V2783 V2786) (if (cons? V2725) (let V2726 (shen.lazyderef (hd V2725) V2786) (if (= fail V2726) (let V2727 (shen.lazyderef (tl V2725) V2786) (if (= () V2727) (let V2728 (shen.lazyderef V2784 V2786) (if (= symbol V2728) (do (shen.incinfs) (thaw V2787)) (if (shen.pvar? V2728) (do (shen.bindv V2728 symbol V2786) (let Result (do (shen.incinfs) (thaw V2787)) (do (shen.unbindv V2728 V2786) Result))) false))) false)) false)) false)) (if (= Case false) (let Case (let NewHyp (shen.newpv V2786) (do (shen.incinfs) (shen.t*-hyps V2785 NewHyp V2786 (freeze (shen.th* V2783 V2784 NewHyp V2786 V2787))))) (if (= Case false) (let Case (let V2729 (shen.lazyderef V2783 V2786) (if (cons? V2729) (let V2730 (shen.lazyderef (hd V2729) V2786) (if (= define V2730) (let V2731 (shen.lazyderef (tl V2729) V2786) (if (cons? V2731) (let F (hd V2731) (let X (tl V2731) (do (shen.incinfs) (cut Throwcontrol V2786 (freeze (shen.t*-def (cons define (cons F X)) V2784 V2785 V2786 V2787)))))) false)) false)) false)) (if (= Case false) (let Case (let V2732 (shen.lazyderef V2783 V2786) (if (cons? V2732) (let V2733 (shen.lazyderef (hd V2732) V2786) (if (= defcc V2733) (let V2734 (shen.lazyderef (tl V2732) V2786) (if (cons? V2734) (let F (hd V2734) (let X (tl V2734) (do (shen.incinfs) (cut Throwcontrol V2786 (freeze (shen.t*-defcc (cons defcc (cons F X)) V2784 V2785 V2786 V2787)))))) false)) false)) false)) (if (= Case false) (let Case (let V2735 (shen.lazyderef V2783 V2786) (if (cons? V2735) (let V2736 (shen.lazyderef (hd V2735) V2786) (if (= shen.process-datatype V2736) (let V2737 (shen.lazyderef V2784 V2786) (if (= symbol V2737) (do (shen.incinfs) (thaw V2787)) (if (shen.pvar? V2737) (do (shen.bindv V2737 symbol V2786) (let Result (do (shen.incinfs) (thaw V2787)) (do (shen.unbindv V2737 V2786) Result))) false))) false)) false)) (if (= Case false) (let Case (let V2738 (shen.lazyderef V2783 V2786) (if (cons? V2738) (let V2739 (shen.lazyderef (hd V2738) V2786) (if (= shen.synonyms-help V2739) (let V2740 (shen.lazyderef V2784 V2786) (if (= symbol V2740) (do (shen.incinfs) (thaw V2787)) (if (shen.pvar? V2740) (do (shen.bindv V2740 symbol V2786) (let Result (do (shen.incinfs) (thaw V2787)) (do (shen.unbindv V2740 V2786) Result))) false))) false)) false)) (if (= Case false) (let Datatypes (shen.newpv V2786) (do (shen.incinfs) (bind Datatypes (value shen.*datatypes*) V2786 (freeze (shen.udefs* (cons V2783 (cons : (cons V2784 ()))) V2785 Datatypes V2786 V2787))))) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)) Case)))))

(defun shen.t*-hyps (V2788 V2789 V2790 V2791) (let Case (let V2535 (shen.lazyderef V2788 V2790) (if (cons? V2535) (let V2536 (shen.lazyderef (hd V2535) V2790) (if (cons? V2536) (let V2537 (shen.lazyderef (hd V2536) V2790) (if (cons? V2537) (let V2538 (shen.lazyderef (hd V2537) V2790) (if (= cons V2538) (let V2539 (shen.lazyderef (tl V2537) V2790) (if (cons? V2539) (let X (hd V2539) (let V2540 (shen.lazyderef (tl V2539) V2790) (if (cons? V2540) (let Y (hd V2540) (let V2541 (shen.lazyderef (tl V2540) V2790) (if (= () V2541) (let V2542 (shen.lazyderef (tl V2536) V2790) (if (cons? V2542) (let V2543 (shen.lazyderef (hd V2542) V2790) (if (= : V2543) (let V2544 (shen.lazyderef (tl V2542) V2790) (if (cons? V2544) (let V2545 (shen.lazyderef (hd V2544) V2790) (if (cons? V2545) (let V2546 (shen.lazyderef (hd V2545) V2790) (if (= list V2546) (let V2547 (shen.lazyderef (tl V2545) V2790) (if (cons? V2547) (let A (hd V2547) (let V2548 (shen.lazyderef (tl V2547) V2790) (if (= () V2548) (let V2549 (shen.lazyderef (tl V2544) V2790) (if (= () V2549) (let Hyp (tl V2535) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (cons list (cons (shen.lazyderef A V2790) ())) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (if (shen.pvar? V2549) (do (shen.bindv V2549 () V2790) (let Result (let Hyp (tl V2535) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (cons list (cons (shen.lazyderef A V2790) ())) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (do (shen.unbindv V2549 V2790) Result))) false))) (if (shen.pvar? V2548) (do (shen.bindv V2548 () V2790) (let Result (let V2550 (shen.lazyderef (tl V2544) V2790) (if (= () V2550) (let Hyp (tl V2535) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (cons list (cons (shen.lazyderef A V2790) ())) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (if (shen.pvar? V2550) (do (shen.bindv V2550 () V2790) (let Result (let Hyp (tl V2535) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (cons list (cons (shen.lazyderef A V2790) ())) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (do (shen.unbindv V2550 V2790) Result))) false))) (do (shen.unbindv V2548 V2790) Result))) false)))) (if (shen.pvar? V2547) (let A (shen.newpv V2790) (do (shen.bindv V2547 (cons A ()) V2790) (let Result (let V2551 (shen.lazyderef (tl V2544) V2790) (if (= () V2551) (let Hyp (tl V2535) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (cons list (cons (shen.lazyderef A V2790) ())) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (if (shen.pvar? V2551) (do (shen.bindv V2551 () V2790) (let Result (let Hyp (tl V2535) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (cons list (cons (shen.lazyderef A V2790) ())) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (do (shen.unbindv V2551 V2790) Result))) false))) (do (shen.unbindv V2547 V2790) Result)))) false))) (if (shen.pvar? V2546) (do (shen.bindv V2546 list V2790) (let Result (let V2552 (shen.lazyderef (tl V2545) V2790) (if (cons? V2552) (let A (hd V2552) (let V2553 (shen.lazyderef (tl V2552) V2790) (if (= () V2553) (let V2554 (shen.lazyderef (tl V2544) V2790) (if (= () V2554) (let Hyp (tl V2535) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (cons list (cons (shen.lazyderef A V2790) ())) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (if (shen.pvar? V2554) (do (shen.bindv V2554 () V2790) (let Result (let Hyp (tl V2535) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (cons list (cons (shen.lazyderef A V2790) ())) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (do (shen.unbindv V2554 V2790) Result))) false))) (if (shen.pvar? V2553) (do (shen.bindv V2553 () V2790) (let Result (let V2555 (shen.lazyderef (tl V2544) V2790) (if (= () V2555) (let Hyp (tl V2535) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (cons list (cons (shen.lazyderef A V2790) ())) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (if (shen.pvar? V2555) (do (shen.bindv V2555 () V2790) (let Result (let Hyp (tl V2535) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (cons list (cons (shen.lazyderef A V2790) ())) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (do (shen.unbindv V2555 V2790) Result))) false))) (do (shen.unbindv V2553 V2790) Result))) false)))) (if (shen.pvar? V2552) (let A (shen.newpv V2790) (do (shen.bindv V2552 (cons A ()) V2790) (let Result (let V2556 (shen.lazyderef (tl V2544) V2790) (if (= () V2556) (let Hyp (tl V2535) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (cons list (cons (shen.lazyderef A V2790) ())) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (if (shen.pvar? V2556) (do (shen.bindv V2556 () V2790) (let Result (let Hyp (tl V2535) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (cons list (cons (shen.lazyderef A V2790) ())) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (do (shen.unbindv V2556 V2790) Result))) false))) (do (shen.unbindv V2552 V2790) Result)))) false))) (do (shen.unbindv V2546 V2790) Result))) false))) (if (shen.pvar? V2545) (let A (shen.newpv V2790) (do (shen.bindv V2545 (cons list (cons A ())) V2790) (let Result (let V2557 (shen.lazyderef (tl V2544) V2790) (if (= () V2557) (let Hyp (tl V2535) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (cons list (cons (shen.lazyderef A V2790) ())) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (if (shen.pvar? V2557) (do (shen.bindv V2557 () V2790) (let Result (let Hyp (tl V2535) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (cons list (cons (shen.lazyderef A V2790) ())) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (do (shen.unbindv V2557 V2790) Result))) false))) (do (shen.unbindv V2545 V2790) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2558 (shen.lazyderef V2788 V2790) (if (cons? V2558) (let V2559 (shen.lazyderef (hd V2558) V2790) (if (cons? V2559) (let V2560 (shen.lazyderef (hd V2559) V2790) (if (cons? V2560) (let V2561 (shen.lazyderef (hd V2560) V2790) (if (= @p V2561) (let V2562 (shen.lazyderef (tl V2560) V2790) (if (cons? V2562) (let X (hd V2562) (let V2563 (shen.lazyderef (tl V2562) V2790) (if (cons? V2563) (let Y (hd V2563) (let V2564 (shen.lazyderef (tl V2563) V2790) (if (= () V2564) (let V2565 (shen.lazyderef (tl V2559) V2790) (if (cons? V2565) (let V2566 (shen.lazyderef (hd V2565) V2790) (if (= : V2566) (let V2567 (shen.lazyderef (tl V2565) V2790) (if (cons? V2567) (let V2568 (shen.lazyderef (hd V2567) V2790) (if (cons? V2568) (let A (hd V2568) (let V2569 (shen.lazyderef (tl V2568) V2790) (if (cons? V2569) (let V2570 (shen.lazyderef (hd V2569) V2790) (if (= * V2570) (let V2571 (shen.lazyderef (tl V2569) V2790) (if (cons? V2571) (let B (hd V2571) (let V2572 (shen.lazyderef (tl V2571) V2790) (if (= () V2572) (let V2573 (shen.lazyderef (tl V2567) V2790) (if (= () V2573) (let Hyp (tl V2558) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (shen.lazyderef B V2790) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (if (shen.pvar? V2573) (do (shen.bindv V2573 () V2790) (let Result (let Hyp (tl V2558) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (shen.lazyderef B V2790) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (do (shen.unbindv V2573 V2790) Result))) false))) (if (shen.pvar? V2572) (do (shen.bindv V2572 () V2790) (let Result (let V2574 (shen.lazyderef (tl V2567) V2790) (if (= () V2574) (let Hyp (tl V2558) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (shen.lazyderef B V2790) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (if (shen.pvar? V2574) (do (shen.bindv V2574 () V2790) (let Result (let Hyp (tl V2558) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (shen.lazyderef B V2790) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (do (shen.unbindv V2574 V2790) Result))) false))) (do (shen.unbindv V2572 V2790) Result))) false)))) (if (shen.pvar? V2571) (let B (shen.newpv V2790) (do (shen.bindv V2571 (cons B ()) V2790) (let Result (let V2575 (shen.lazyderef (tl V2567) V2790) (if (= () V2575) (let Hyp (tl V2558) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (shen.lazyderef B V2790) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (if (shen.pvar? V2575) (do (shen.bindv V2575 () V2790) (let Result (let Hyp (tl V2558) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (shen.lazyderef B V2790) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (do (shen.unbindv V2575 V2790) Result))) false))) (do (shen.unbindv V2571 V2790) Result)))) false))) (if (shen.pvar? V2570) (do (shen.bindv V2570 * V2790) (let Result (let V2576 (shen.lazyderef (tl V2569) V2790) (if (cons? V2576) (let B (hd V2576) (let V2577 (shen.lazyderef (tl V2576) V2790) (if (= () V2577) (let V2578 (shen.lazyderef (tl V2567) V2790) (if (= () V2578) (let Hyp (tl V2558) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (shen.lazyderef B V2790) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (if (shen.pvar? V2578) (do (shen.bindv V2578 () V2790) (let Result (let Hyp (tl V2558) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (shen.lazyderef B V2790) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (do (shen.unbindv V2578 V2790) Result))) false))) (if (shen.pvar? V2577) (do (shen.bindv V2577 () V2790) (let Result (let V2579 (shen.lazyderef (tl V2567) V2790) (if (= () V2579) (let Hyp (tl V2558) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (shen.lazyderef B V2790) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (if (shen.pvar? V2579) (do (shen.bindv V2579 () V2790) (let Result (let Hyp (tl V2558) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (shen.lazyderef B V2790) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (do (shen.unbindv V2579 V2790) Result))) false))) (do (shen.unbindv V2577 V2790) Result))) false)))) (if (shen.pvar? V2576) (let B (shen.newpv V2790) (do (shen.bindv V2576 (cons B ()) V2790) (let Result (let V2580 (shen.lazyderef (tl V2567) V2790) (if (= () V2580) (let Hyp (tl V2558) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (shen.lazyderef B V2790) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (if (shen.pvar? V2580) (do (shen.bindv V2580 () V2790) (let Result (let Hyp (tl V2558) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (shen.lazyderef B V2790) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (do (shen.unbindv V2580 V2790) Result))) false))) (do (shen.unbindv V2576 V2790) Result)))) false))) (do (shen.unbindv V2570 V2790) Result))) false))) (if (shen.pvar? V2569) (let B (shen.newpv V2790) (do (shen.bindv V2569 (cons * (cons B ())) V2790) (let Result (let V2581 (shen.lazyderef (tl V2567) V2790) (if (= () V2581) (let Hyp (tl V2558) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (shen.lazyderef B V2790) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (if (shen.pvar? V2581) (do (shen.bindv V2581 () V2790) (let Result (let Hyp (tl V2558) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (shen.lazyderef B V2790) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (do (shen.unbindv V2581 V2790) Result))) false))) (do (shen.unbindv V2569 V2790) Result)))) false)))) (if (shen.pvar? V2568) (let A (shen.newpv V2790) (let B (shen.newpv V2790) (do (shen.bindv V2568 (cons A (cons * (cons B ()))) V2790) (let Result (let V2582 (shen.lazyderef (tl V2567) V2790) (if (= () V2582) (let Hyp (tl V2558) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (shen.lazyderef B V2790) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (if (shen.pvar? V2582) (do (shen.bindv V2582 () V2790) (let Result (let Hyp (tl V2558) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (shen.lazyderef B V2790) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (do (shen.unbindv V2582 V2790) Result))) false))) (do (shen.unbindv V2568 V2790) Result))))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2583 (shen.lazyderef V2788 V2790) (if (cons? V2583) (let V2584 (shen.lazyderef (hd V2583) V2790) (if (cons? V2584) (let V2585 (shen.lazyderef (hd V2584) V2790) (if (cons? V2585) (let V2586 (shen.lazyderef (hd V2585) V2790) (if (= @v V2586) (let V2587 (shen.lazyderef (tl V2585) V2790) (if (cons? V2587) (let X (hd V2587) (let V2588 (shen.lazyderef (tl V2587) V2790) (if (cons? V2588) (let Y (hd V2588) (let V2589 (shen.lazyderef (tl V2588) V2790) (if (= () V2589) (let V2590 (shen.lazyderef (tl V2584) V2790) (if (cons? V2590) (let V2591 (shen.lazyderef (hd V2590) V2790) (if (= : V2591) (let V2592 (shen.lazyderef (tl V2590) V2790) (if (cons? V2592) (let V2593 (shen.lazyderef (hd V2592) V2790) (if (cons? V2593) (let V2594 (shen.lazyderef (hd V2593) V2790) (if (= vector V2594) (let V2595 (shen.lazyderef (tl V2593) V2790) (if (cons? V2595) (let A (hd V2595) (let V2596 (shen.lazyderef (tl V2595) V2790) (if (= () V2596) (let V2597 (shen.lazyderef (tl V2592) V2790) (if (= () V2597) (let Hyp (tl V2583) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (cons vector (cons (shen.lazyderef A V2790) ())) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (if (shen.pvar? V2597) (do (shen.bindv V2597 () V2790) (let Result (let Hyp (tl V2583) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (cons vector (cons (shen.lazyderef A V2790) ())) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (do (shen.unbindv V2597 V2790) Result))) false))) (if (shen.pvar? V2596) (do (shen.bindv V2596 () V2790) (let Result (let V2598 (shen.lazyderef (tl V2592) V2790) (if (= () V2598) (let Hyp (tl V2583) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (cons vector (cons (shen.lazyderef A V2790) ())) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (if (shen.pvar? V2598) (do (shen.bindv V2598 () V2790) (let Result (let Hyp (tl V2583) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (cons vector (cons (shen.lazyderef A V2790) ())) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (do (shen.unbindv V2598 V2790) Result))) false))) (do (shen.unbindv V2596 V2790) Result))) false)))) (if (shen.pvar? V2595) (let A (shen.newpv V2790) (do (shen.bindv V2595 (cons A ()) V2790) (let Result (let V2599 (shen.lazyderef (tl V2592) V2790) (if (= () V2599) (let Hyp (tl V2583) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (cons vector (cons (shen.lazyderef A V2790) ())) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (if (shen.pvar? V2599) (do (shen.bindv V2599 () V2790) (let Result (let Hyp (tl V2583) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (cons vector (cons (shen.lazyderef A V2790) ())) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (do (shen.unbindv V2599 V2790) Result))) false))) (do (shen.unbindv V2595 V2790) Result)))) false))) (if (shen.pvar? V2594) (do (shen.bindv V2594 vector V2790) (let Result (let V2600 (shen.lazyderef (tl V2593) V2790) (if (cons? V2600) (let A (hd V2600) (let V2601 (shen.lazyderef (tl V2600) V2790) (if (= () V2601) (let V2602 (shen.lazyderef (tl V2592) V2790) (if (= () V2602) (let Hyp (tl V2583) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (cons vector (cons (shen.lazyderef A V2790) ())) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (if (shen.pvar? V2602) (do (shen.bindv V2602 () V2790) (let Result (let Hyp (tl V2583) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (cons vector (cons (shen.lazyderef A V2790) ())) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (do (shen.unbindv V2602 V2790) Result))) false))) (if (shen.pvar? V2601) (do (shen.bindv V2601 () V2790) (let Result (let V2603 (shen.lazyderef (tl V2592) V2790) (if (= () V2603) (let Hyp (tl V2583) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (cons vector (cons (shen.lazyderef A V2790) ())) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (if (shen.pvar? V2603) (do (shen.bindv V2603 () V2790) (let Result (let Hyp (tl V2583) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (cons vector (cons (shen.lazyderef A V2790) ())) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (do (shen.unbindv V2603 V2790) Result))) false))) (do (shen.unbindv V2601 V2790) Result))) false)))) (if (shen.pvar? V2600) (let A (shen.newpv V2790) (do (shen.bindv V2600 (cons A ()) V2790) (let Result (let V2604 (shen.lazyderef (tl V2592) V2790) (if (= () V2604) (let Hyp (tl V2583) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (cons vector (cons (shen.lazyderef A V2790) ())) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (if (shen.pvar? V2604) (do (shen.bindv V2604 () V2790) (let Result (let Hyp (tl V2583) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (cons vector (cons (shen.lazyderef A V2790) ())) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (do (shen.unbindv V2604 V2790) Result))) false))) (do (shen.unbindv V2600 V2790) Result)))) false))) (do (shen.unbindv V2594 V2790) Result))) false))) (if (shen.pvar? V2593) (let A (shen.newpv V2790) (do (shen.bindv V2593 (cons vector (cons A ())) V2790) (let Result (let V2605 (shen.lazyderef (tl V2592) V2790) (if (= () V2605) (let Hyp (tl V2583) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (cons vector (cons (shen.lazyderef A V2790) ())) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (if (shen.pvar? V2605) (do (shen.bindv V2605 () V2790) (let Result (let Hyp (tl V2583) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons (shen.lazyderef A V2790) ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons (cons vector (cons (shen.lazyderef A V2790) ())) ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (do (shen.unbindv V2605 V2790) Result))) false))) (do (shen.unbindv V2593 V2790) Result)))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let Case (let V2606 (shen.lazyderef V2788 V2790) (if (cons? V2606) (let V2607 (shen.lazyderef (hd V2606) V2790) (if (cons? V2607) (let V2608 (shen.lazyderef (hd V2607) V2790) (if (cons? V2608) (let V2609 (shen.lazyderef (hd V2608) V2790) (if (= @s V2609) (let V2610 (shen.lazyderef (tl V2608) V2790) (if (cons? V2610) (let X (hd V2610) (let V2611 (shen.lazyderef (tl V2610) V2790) (if (cons? V2611) (let Y (hd V2611) (let V2612 (shen.lazyderef (tl V2611) V2790) (if (= () V2612) (let V2613 (shen.lazyderef (tl V2607) V2790) (if (cons? V2613) (let V2614 (shen.lazyderef (hd V2613) V2790) (if (= : V2614) (let V2615 (shen.lazyderef (tl V2613) V2790) (if (cons? V2615) (let V2616 (shen.lazyderef (hd V2615) V2790) (if (= string V2616) (let V2617 (shen.lazyderef (tl V2615) V2790) (if (= () V2617) (let Hyp (tl V2606) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons string ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (if (shen.pvar? V2617) (do (shen.bindv V2617 () V2790) (let Result (let Hyp (tl V2606) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons string ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (do (shen.unbindv V2617 V2790) Result))) false))) (if (shen.pvar? V2616) (do (shen.bindv V2616 string V2790) (let Result (let V2618 (shen.lazyderef (tl V2615) V2790) (if (= () V2618) (let Hyp (tl V2606) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons string ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (if (shen.pvar? V2618) (do (shen.bindv V2618 () V2790) (let Result (let Hyp (tl V2606) (do (shen.incinfs) (bind V2789 (cons (cons (shen.lazyderef X V2790) (cons : (cons string ()))) (cons (cons (shen.lazyderef Y V2790) (cons : (cons string ()))) (shen.lazyderef Hyp V2790))) V2790 V2791))) (do (shen.unbindv V2618 V2790) Result))) false))) (do (shen.unbindv V2616 V2790) Result))) false))) false)) false)) false)) false))) false))) false)) false)) false)) false)) false)) (if (= Case false) (let V2619 (shen.lazyderef V2788 V2790) (if (cons? V2619) (let X (hd V2619) (let Hyp (tl V2619) (let NewHyps (shen.newpv V2790) (do (shen.incinfs) (bind V2789 (cons (shen.lazyderef X V2790) (shen.lazyderef NewHyps V2790)) V2790 (freeze (shen.t*-hyps Hyp NewHyps V2790 V2791))))))) false)) Case)) Case)) Case)) Case)))

(defun shen.show (V2804 V2805 V2806 V2807) (cond ((value shen.*spy*) (do (shen.line) (do (shen.show-p (shen.deref V2804 V2806)) (do (nl 1) (do (nl 1) (do (shen.show-assumptions (shen.deref V2805 V2806) 1) (do (pr "
> " (stoutput)) (do (shen.pause-for-user (value *language*)) (thaw V2807))))))))) (true (thaw V2807))))

(defun shen.line () (let Infs (inferences) (pr (cn "____________________________________________________________ " (shen.app Infs (cn " inference" (shen.app (if (= 1 Infs) "" "s") " 
?- " shen.a)) shen.a)) (stoutput))))

(defun shen.show-p (V2808) (cond ((and (cons? V2808) (and (cons? (tl V2808)) (and (= : (hd (tl V2808))) (and (cons? (tl (tl V2808))) (= () (tl (tl (tl V2808)))))))) (pr (shen.app (hd V2808) (cn " : " (shen.app (hd (tl (tl V2808))) "" shen.r)) shen.r) (stoutput))) (true (pr (shen.app V2808 "" shen.r) (stoutput)))))

(defun shen.show-assumptions (V2811 V2812) (cond ((= () V2811) shen.skip) ((cons? V2811) (do (pr (shen.app V2812 ". " shen.a) (stoutput)) (do (shen.show-p (hd V2811)) (do (nl 1) (shen.show-assumptions (tl V2811) (+ V2812 1)))))) (true (shen.sys-error shen.show-assumptions))))

(defun shen.pause-for-user (V2817) (cond ((= "Common Lisp" V2817) (let I (FORMAT () "~C" (READ-CHAR)) (if (= I "a") (simple-error "input aborted
") (nl 1)))) (true (let I (shen.read-char) (if (= I "a") (simple-error "input aborted
") (nl 1))))))

(defun shen.read-char () (shen.read-char-h (read-byte (stinput)) 0))

(defun shen.read-char-h (V2820 V2821) (cond ((and (= -1 V2820) (= 0 V2821)) (shen.read-char-h (read-byte (stinput)) 1)) ((= 0 V2821) (shen.read-char-h (read-byte (stinput)) 0)) ((and (= -1 V2820) (= 1 V2821)) (shen.read-char-h (read-byte (stinput)) 1)) ((= 1 V2821) (n->string V2820)) (true (shen.sys-error shen.read-char-h))))

(defun shen.typedf? (V2822) (element? V2822 (value shen.*signedfuncs*)))

(defun shen.sigf (V2823) (concat shen.type-signature-of- V2823))

(defun shen.placeholder () (gensym &&))

(defun shen.base (V2824 V2825 V2826 V2827) (let Case (let V2522 (shen.lazyderef V2825 V2826) (if (= number V2522) (do (shen.incinfs) (fwhen (number? (shen.lazyderef V2824 V2826)) V2826 V2827)) (if (shen.pvar? V2522) (do (shen.bindv V2522 number V2826) (let Result (do (shen.incinfs) (fwhen (number? (shen.lazyderef V2824 V2826)) V2826 V2827)) (do (shen.unbindv V2522 V2826) Result))) false))) (if (= Case false) (let Case (let V2523 (shen.lazyderef V2825 V2826) (if (= boolean V2523) (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V2824 V2826)) V2826 V2827)) (if (shen.pvar? V2523) (do (shen.bindv V2523 boolean V2826) (let Result (do (shen.incinfs) (fwhen (boolean? (shen.lazyderef V2824 V2826)) V2826 V2827)) (do (shen.unbindv V2523 V2826) Result))) false))) (if (= Case false) (let Case (let V2524 (shen.lazyderef V2825 V2826) (if (= string V2524) (do (shen.incinfs) (fwhen (string? (shen.lazyderef V2824 V2826)) V2826 V2827)) (if (shen.pvar? V2524) (do (shen.bindv V2524 string V2826) (let Result (do (shen.incinfs) (fwhen (string? (shen.lazyderef V2824 V2826)) V2826 V2827)) (do (shen.unbindv V2524 V2826) Result))) false))) (if (= Case false) (let Case (let V2525 (shen.lazyderef V2825 V2826) (if (= symbol V2525) (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V2824 V2826)) V2826 (freeze (fwhen (not (shen.placeholder? (shen.lazyderef V2824 V2826))) V2826 V2827)))) (if (shen.pvar? V2525) (do (shen.bindv V2525 symbol V2826) (let Result (do (shen.incinfs) (fwhen (symbol? (shen.lazyderef V2824 V2826)) V2826 (freeze (fwhen (not (shen.placeholder? (shen.lazyderef V2824 V2826))) V2826 V2827)))) (do (shen.unbindv V2525 V2826) Result))) false))) (if (= Case false) (let V2526 (shen.lazyderef V2824 V2826) (if (= () V2526) (let V2527 (shen.lazyderef V2825 V2826) (if (cons? V2527) (let V2528 (shen.lazyderef (hd V2527) V2826) (if (= list V2528) (let V2529 (shen.lazyderef (tl V2527) V2826) (if (cons? V2529) (let A (hd V2529) (let V2530 (shen.lazyderef (tl V2529) V2826) (if (= () V2530) (do (shen.incinfs) (thaw V2827)) (if (shen.pvar? V2530) (do (shen.bindv V2530 () V2826) (let Result (do (shen.incinfs) (thaw V2827)) (do (shen.unbindv V2530 V2826) Result))) false)))) (if (shen.pvar? V2529) (let A (shen.newpv V2826) (do (shen.bindv V2529 (cons A ()) V2826) (let Result (do (shen.incinfs) (thaw V2827)) (do (shen.unbindv V2529 V2826) Result)))) false))) (if (shen.pvar? V2528) (do (shen.bindv V2528 list V2826) (let Result (let V2531 (shen.lazyderef (tl V2527) V2826) (if (cons? V2531) (let A (hd V2531) (let V2532 (shen.lazyderef (tl V2531) V2826) (if (= () V2532) (do (shen.incinfs) (thaw V2827)) (if (shen.pvar? V2532) (do (shen.bindv V2532 () V2826) (let Result (do (shen.incinfs) (thaw V2827)) (do (shen.unbindv V2532 V2826) Result))) false)))) (if (shen.pvar? V2531) (let A (shen.newpv V2826) (do (shen.bindv V2531 (cons A ()) V2826) (let Result (do (shen.incinfs) (thaw V2827)) (do (shen.unbindv V2531 V2826) Result)))) false))) (do (shen.unbindv V2528 V2826) Result))) false))) (if (shen.pvar? V2527) (let A (shen.newpv V2826) (do (shen.bindv V2527 (cons list (cons A ())) V2826) (let Result (do (shen.incinfs) (thaw V2827)) (do (shen.unbindv V2527 V2826) Result)))) false))) false)) Case)) Case)) Case)) Case)))

(defun shen.placeholder? (V2828) (and (symbol? V2828) (shen.placeholder-help? (str V2828))))

(defun shen.placeholder-help? (V2835) (cond ((and (shen.+string? V2835) (and (= "&" (pos V2835 0)) (and (shen.+string? (tlstr V2835)) (= "&" (pos (tlstr V2835) 0))))) true) (true false)))

(defun shen.by_hypothesis (V2836 V2837 V2838 V2839 V2840) (let Case (let V2513 (shen.lazyderef V2838 V2839) (if (cons? V2513) (let V2514 (shen.lazyderef (hd V2513) V2839) (if (cons? V2514) (let Y (hd V2514) (let V2515 (shen.lazyderef (tl V2514) V2839) (if (cons? V2515) (let V2516 (shen.lazyderef (hd V2515) V2839) (if (= : V2516) (let V2517 (shen.lazyderef (tl V2515) V2839) (if (cons? V2517) (let B (hd V2517) (let V2518 (shen.lazyderef (tl V2517) V2839) (if (= () V2518) (do (shen.incinfs) (identical V2836 Y V2839 (freeze (unify! V2837 B V2839 V2840)))) false))) false)) false)) false))) false)) false)) (if (= Case false) (let V2519 (shen.lazyderef V2838 V2839) (if (cons? V2519) (let Hyp (tl V2519) (do (shen.incinfs) (shen.by_hypothesis V2836 V2837 Hyp V2839 V2840))) false)) Case)))

(defun shen.t*-def (V2841 V2842 V2843 V2844 V2845) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let V2507 (shen.lazyderef V2841 V2844) (if (cons? V2507) (let V2508 (shen.lazyderef (hd V2507) V2844) (if (= define V2508) (let V2509 (shen.lazyderef (tl V2507) V2844) (if (cons? V2509) (let F (hd V2509) (let X (tl V2509) (let Error (shen.newpv V2844) (let Sig+Rules (shen.newpv V2844) (let Vars (shen.newpv V2844) (let Rules (shen.newpv V2844) (let Sig&& (shen.newpv V2844) (let Declare (shen.newpv V2844) (let Sig (shen.newpv V2844) (do (shen.incinfs) (bind Sig+Rules (compile shen.<sig+rules> (shen.lazyderef X V2844) ()) V2844 (freeze (bind Error (if (= (shen.lazyderef Sig+Rules V2844) (fail)) (shen.errordef (shen.lazyderef F V2844)) shen.skip) V2844 (freeze (bind Sig (hd (shen.lazyderef Sig+Rules V2844)) V2844 (freeze (bind Rules (tl (shen.lazyderef Sig+Rules V2844)) V2844 (freeze (bind Vars (shen.extract_vars (shen.lazyderef Sig V2844)) V2844 (freeze (bind Sig&& (shen.placeholders (shen.lazyderef Sig V2844) (shen.lazyderef Vars V2844)) V2844 (freeze (cut Throwcontrol V2844 (freeze (shen.t*-rules Rules Sig&& 1 F (cons (cons F (cons : (cons Sig&& ()))) V2843) V2844 (freeze (bind Declare (declare (shen.lazyderef F V2844) (shen.lazyderef Sig V2844)) V2844 (freeze (unify! V2842 Sig V2844 V2845))))))))))))))))))))))))))))) false)) false)) false)))))

(defun shen.<sig+rules> (V2850) (let Result (let Parse_shen.<signature> (shen.<signature> V2850) (if (not (= (fail) Parse_shen.<signature>)) (let Parse_shen.<trules> (shen.<trules> Parse_shen.<signature>) (if (not (= (fail) Parse_shen.<trules>)) (shen.pair (hd Parse_shen.<trules>) (cons (shen.hdtl Parse_shen.<signature>) (shen.hdtl Parse_shen.<trules>))) (fail))) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.placeholders (V2855 V2856) (cond ((cons? V2855) (map (lambda Z (shen.placeholders Z V2856)) V2855)) ((element? V2855 V2856) (concat && V2855)) (true V2855)))

(defun shen.<trules> (V2861) (let Result (let Parse_shen.<trule> (shen.<trule> V2861) (if (not (= (fail) Parse_shen.<trule>)) (let Parse_shen.<trules> (shen.<trules> Parse_shen.<trule>) (if (not (= (fail) Parse_shen.<trules>)) (shen.pair (hd Parse_shen.<trules>) (cons (shen.hdtl Parse_shen.<trule>) (shen.hdtl Parse_shen.<trules>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_shen.<trule> (shen.<trule> V2861) (if (not (= (fail) Parse_shen.<trule>)) (shen.pair (hd Parse_shen.<trule>) (cons (shen.hdtl Parse_shen.<trule>) ())) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<trule> (V2866) (let Result (let Parse_shen.<patterns> (shen.<patterns> V2866) (if (not (= (fail) Parse_shen.<patterns>)) (let Parse_shen.<arrow> (shen.<arrow> Parse_shen.<patterns>) (if (not (= (fail) Parse_shen.<arrow>)) (let Parse_shen.<action> (shen.<action> Parse_shen.<arrow>) (if (not (= (fail) Parse_shen.<action>)) (let Parse_shen.<guard?> (shen.<guard?> Parse_shen.<action>) (if (not (= (fail) Parse_shen.<guard?>)) (shen.pair (hd Parse_shen.<guard?>) (let Parse_Vars (shen.extract_vars (shen.hdtl Parse_shen.<patterns>)) (let Parse_Patterns (shen.placeholders (shen.hdtl Parse_shen.<patterns>) Parse_Vars) (let Parse_Action (shen.placeholders (shen.curry (shen.hdtl Parse_shen.<action>)) Parse_Vars) (let Parse_Guard (shen.placeholders (shen.curry (shen.hdtl Parse_shen.<guard?>)) Parse_Vars) (shen.form-rule Parse_Patterns (shen.hdtl Parse_shen.<arrow>) Parse_Action Parse_Guard)))))) (fail))) (fail))) (fail))) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.form-rule (V2867 V2868 V2869 V2870) (cond ((= shen.forward V2868) (cons V2867 (cons (if (= V2870 shen.skip) V2869 (cons where (cons V2870 (cons V2869 ())))) ()))) ((and (= shen.backward V2868) (and (cons? V2869) (and (cons? (hd V2869)) (and (= fail-if (hd (hd V2869))) (and (cons? (tl (hd V2869))) (and (= () (tl (tl (hd V2869)))) (and (cons? (tl V2869)) (= () (tl (tl V2869)))))))))) (cons V2867 (cons (if (= V2870 shen.skip) (cons where (cons (cons not (cons (cons (hd (tl (hd V2869))) (tl V2869)) ())) (tl V2869))) (cons where (cons (cons (cons and (cons V2870 ())) (cons (cons not (cons (cons (hd (tl (hd V2869))) (tl V2869)) ())) ())) (tl V2869)))) ()))) ((= shen.backward V2868) (cons V2867 (cons (if (= V2870 shen.skip) (cons where (cons (cons not (cons (cons (cons == (cons V2869 ())) (cons (cons fail ()) ())) ())) (cons V2869 ()))) (cons where (cons (cons (cons and (cons V2870 ())) (cons (cons not (cons (cons (cons == (cons V2869 ())) (cons (cons fail ()) ())) ())) ())) (cons V2869 ())))) ()))) (true (shen.sys-error shen.form-rule))))

(defun shen.<guard?> (V2875) (let Result (if (and (cons? (hd V2875)) (= where (hd (hd V2875)))) (let Parse_shen.<guard> (shen.<guard> (shen.pair (tl (hd V2875)) (shen.hdtl V2875))) (if (not (= (fail) Parse_shen.<guard>)) (shen.pair (hd Parse_shen.<guard>) (shen.hdtl Parse_shen.<guard>)) (fail))) (fail)) (if (= Result (fail)) (let Result (let Parse_<e> (<e> V2875) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) shen.skip) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<arrow> (V2880) (let Result (if (and (cons? (hd V2880)) (= -> (hd (hd V2880)))) (shen.pair (hd (shen.pair (tl (hd V2880)) (shen.hdtl V2880))) shen.forward) (fail)) (if (= Result (fail)) (let Result (if (and (cons? (hd V2880)) (= <- (hd (hd V2880)))) (shen.pair (hd (shen.pair (tl (hd V2880)) (shen.hdtl V2880))) shen.backward) (fail)) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.errordef (V2881) (simple-error (cn "syntax error in " (shen.app V2881 "
" shen.a))))

(defun shen.t*-rules (V2882 V2883 V2884 V2885 V2886 V2887 V2888) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2502 (shen.lazyderef V2882 V2887) (if (= () V2502) (do (shen.incinfs) (thaw V2888)) false)) (if (= Case false) (let V2503 (shen.lazyderef V2882 V2887) (if (cons? V2503) (let Rule (hd V2503) (let Rules (tl V2503) (let M (shen.newpv V2887) (do (shen.incinfs) (shen.t*-rule Rule V2883 V2884 V2885 V2886 V2887 (freeze (cut Throwcontrol V2887 (freeze (bind M (+ (shen.lazyderef V2884 V2887) 1) V2887 (freeze (shen.t*-rules Rules V2883 M V2885 V2886 V2887 V2888))))))))))) false)) Case)))))

(defun shen.t*-rule (V2889 V2890 V2891 V2892 V2893 V2894 V2895) (let Case (do (shen.incinfs) (shen.t*-ruleh V2889 V2890 V2893 V2894 V2895)) (if (= Case false) (let Error (shen.newpv V2894) (do (shen.incinfs) (bind Error (shen.type-insecure-rule-error-message (shen.lazyderef V2891 V2894) (shen.lazyderef V2892 V2894)) V2894 V2895))) Case)))

(defun shen.t*-ruleh (V2896 V2897 V2898 V2899 V2900) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2479 (shen.lazyderef V2896 V2899) (if (cons? V2479) (let V2480 (shen.lazyderef (hd V2479) V2899) (if (= () V2480) (let V2481 (shen.lazyderef (tl V2479) V2899) (if (cons? V2481) (let Result (hd V2481) (let V2482 (shen.lazyderef (tl V2481) V2899) (if (= () V2482) (let V2483 (shen.lazyderef V2897 V2899) (if (cons? V2483) (let V2484 (shen.lazyderef (hd V2483) V2899) (if (= --> V2484) (let V2485 (shen.lazyderef (tl V2483) V2899) (if (cons? V2485) (let A (hd V2485) (let V2486 (shen.lazyderef (tl V2485) V2899) (if (= () V2486) (do (shen.incinfs) (cut Throwcontrol V2899 (freeze (shen.th* Result A V2898 V2899 V2900)))) (if (shen.pvar? V2486) (do (shen.bindv V2486 () V2899) (let Result (do (shen.incinfs) (cut Throwcontrol V2899 (freeze (shen.th* Result A V2898 V2899 V2900)))) (do (shen.unbindv V2486 V2899) Result))) false)))) (if (shen.pvar? V2485) (let A (shen.newpv V2899) (do (shen.bindv V2485 (cons A ()) V2899) (let Result (do (shen.incinfs) (cut Throwcontrol V2899 (freeze (shen.th* Result A V2898 V2899 V2900)))) (do (shen.unbindv V2485 V2899) Result)))) false))) (if (shen.pvar? V2484) (do (shen.bindv V2484 --> V2899) (let Result (let V2487 (shen.lazyderef (tl V2483) V2899) (if (cons? V2487) (let A (hd V2487) (let V2488 (shen.lazyderef (tl V2487) V2899) (if (= () V2488) (do (shen.incinfs) (cut Throwcontrol V2899 (freeze (shen.th* Result A V2898 V2899 V2900)))) (if (shen.pvar? V2488) (do (shen.bindv V2488 () V2899) (let Result (do (shen.incinfs) (cut Throwcontrol V2899 (freeze (shen.th* Result A V2898 V2899 V2900)))) (do (shen.unbindv V2488 V2899) Result))) false)))) (if (shen.pvar? V2487) (let A (shen.newpv V2899) (do (shen.bindv V2487 (cons A ()) V2899) (let Result (do (shen.incinfs) (cut Throwcontrol V2899 (freeze (shen.th* Result A V2898 V2899 V2900)))) (do (shen.unbindv V2487 V2899) Result)))) false))) (do (shen.unbindv V2484 V2899) Result))) false))) (if (shen.pvar? V2483) (let A (shen.newpv V2899) (do (shen.bindv V2483 (cons --> (cons A ())) V2899) (let Result (do (shen.incinfs) (cut Throwcontrol V2899 (freeze (shen.th* Result A V2898 V2899 V2900)))) (do (shen.unbindv V2483 V2899) Result)))) false))) false))) false)) false)) false)) (if (= Case false) (let V2489 (shen.lazyderef V2896 V2899) (if (cons? V2489) (let Patterns (hd V2489) (let V2490 (shen.lazyderef (tl V2489) V2899) (if (cons? V2490) (let Result (hd V2490) (let V2491 (shen.lazyderef (tl V2490) V2899) (if (= () V2491) (let NewHyp (shen.newpv V2899) (let B (shen.newpv V2899) (let AllHyp (shen.newpv V2899) (do (shen.incinfs) (shen.t*-patterns Patterns V2897 NewHyp B V2899 (freeze (cut Throwcontrol V2899 (freeze (shen.conc NewHyp V2898 AllHyp V2899 (freeze (cut Throwcontrol V2899 (freeze (shen.th* Result B AllHyp V2899 V2900))))))))))))) false))) false))) false)) Case)))))

(defun shen.type-insecure-rule-error-message (V2901 V2902) (simple-error (cn "type error in rule " (shen.app V2901 (cn " of " (shen.app V2902 "
" shen.a)) shen.a))))

(defun shen.t*-patterns (V2903 V2904 V2905 V2906 V2907 V2908) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2460 (shen.lazyderef V2903 V2907) (if (= () V2460) (let V2461 (shen.lazyderef V2905 V2907) (if (= () V2461) (do (shen.incinfs) (unify! V2906 V2904 V2907 V2908)) (if (shen.pvar? V2461) (do (shen.bindv V2461 () V2907) (let Result (do (shen.incinfs) (unify! V2906 V2904 V2907 V2908)) (do (shen.unbindv V2461 V2907) Result))) false))) false)) (if (= Case false) (let V2462 (shen.lazyderef V2903 V2907) (if (cons? V2462) (let Pattern2454 (hd V2462) (let Patterns (tl V2462) (let V2463 (shen.lazyderef V2904 V2907) (if (cons? V2463) (let A2455 (hd V2463) (let V2464 (shen.lazyderef (tl V2463) V2907) (if (cons? V2464) (let V2465 (shen.lazyderef (hd V2464) V2907) (if (= --> V2465) (let V2466 (shen.lazyderef (tl V2464) V2907) (if (cons? V2466) (let B (hd V2466) (let V2467 (shen.lazyderef (tl V2466) V2907) (if (= () V2467) (let V2468 (shen.lazyderef V2905 V2907) (if (cons? V2468) (let V2469 (shen.lazyderef (hd V2468) V2907) (if (cons? V2469) (let Pattern (hd V2469) (let V2470 (shen.lazyderef (tl V2469) V2907) (if (cons? V2470) (let V2471 (shen.lazyderef (hd V2470) V2907) (if (= : V2471) (let V2472 (shen.lazyderef (tl V2470) V2907) (if (cons? V2472) (let A (hd V2472) (let V2473 (shen.lazyderef (tl V2472) V2907) (if (= () V2473) (let Hyp (tl V2468) (let Assume (shen.newpv V2907) (do (shen.incinfs) (unify! A A2455 V2907 (freeze (unify! Pattern Pattern2454 V2907 (freeze (shen.t*-assume Pattern Assume V2907 (freeze (cut Throwcontrol V2907 (freeze (shen.th* Pattern A Assume V2907 (freeze (cut Throwcontrol V2907 (freeze (shen.t*-patterns Patterns B Hyp V2906 V2907 V2908)))))))))))))))) (if (shen.pvar? V2473) (do (shen.bindv V2473 () V2907) (let Result (let Hyp (tl V2468) (let Assume (shen.newpv V2907) (do (shen.incinfs) (unify! A A2455 V2907 (freeze (unify! Pattern Pattern2454 V2907 (freeze (shen.t*-assume Pattern Assume V2907 (freeze (cut Throwcontrol V2907 (freeze (shen.th* Pattern A Assume V2907 (freeze (cut Throwcontrol V2907 (freeze (shen.t*-patterns Patterns B Hyp V2906 V2907 V2908)))))))))))))))) (do (shen.unbindv V2473 V2907) Result))) false)))) (if (shen.pvar? V2472) (let A (shen.newpv V2907) (do (shen.bindv V2472 (cons A ()) V2907) (let Result (let Hyp (tl V2468) (let Assume (shen.newpv V2907) (do (shen.incinfs) (unify! A A2455 V2907 (freeze (unify! Pattern Pattern2454 V2907 (freeze (shen.t*-assume Pattern Assume V2907 (freeze (cut Throwcontrol V2907 (freeze (shen.th* Pattern A Assume V2907 (freeze (cut Throwcontrol V2907 (freeze (shen.t*-patterns Patterns B Hyp V2906 V2907 V2908)))))))))))))))) (do (shen.unbindv V2472 V2907) Result)))) false))) (if (shen.pvar? V2471) (do (shen.bindv V2471 : V2907) (let Result (let V2474 (shen.lazyderef (tl V2470) V2907) (if (cons? V2474) (let A (hd V2474) (let V2475 (shen.lazyderef (tl V2474) V2907) (if (= () V2475) (let Hyp (tl V2468) (let Assume (shen.newpv V2907) (do (shen.incinfs) (unify! A A2455 V2907 (freeze (unify! Pattern Pattern2454 V2907 (freeze (shen.t*-assume Pattern Assume V2907 (freeze (cut Throwcontrol V2907 (freeze (shen.th* Pattern A Assume V2907 (freeze (cut Throwcontrol V2907 (freeze (shen.t*-patterns Patterns B Hyp V2906 V2907 V2908)))))))))))))))) (if (shen.pvar? V2475) (do (shen.bindv V2475 () V2907) (let Result (let Hyp (tl V2468) (let Assume (shen.newpv V2907) (do (shen.incinfs) (unify! A A2455 V2907 (freeze (unify! Pattern Pattern2454 V2907 (freeze (shen.t*-assume Pattern Assume V2907 (freeze (cut Throwcontrol V2907 (freeze (shen.th* Pattern A Assume V2907 (freeze (cut Throwcontrol V2907 (freeze (shen.t*-patterns Patterns B Hyp V2906 V2907 V2908)))))))))))))))) (do (shen.unbindv V2475 V2907) Result))) false)))) (if (shen.pvar? V2474) (let A (shen.newpv V2907) (do (shen.bindv V2474 (cons A ()) V2907) (let Result (let Hyp (tl V2468) (let Assume (shen.newpv V2907) (do (shen.incinfs) (unify! A A2455 V2907 (freeze (unify! Pattern Pattern2454 V2907 (freeze (shen.t*-assume Pattern Assume V2907 (freeze (cut Throwcontrol V2907 (freeze (shen.th* Pattern A Assume V2907 (freeze (cut Throwcontrol V2907 (freeze (shen.t*-patterns Patterns B Hyp V2906 V2907 V2908)))))))))))))))) (do (shen.unbindv V2474 V2907) Result)))) false))) (do (shen.unbindv V2471 V2907) Result))) false))) (if (shen.pvar? V2470) (let A (shen.newpv V2907) (do (shen.bindv V2470 (cons : (cons A ())) V2907) (let Result (let Hyp (tl V2468) (let Assume (shen.newpv V2907) (do (shen.incinfs) (unify! A A2455 V2907 (freeze (unify! Pattern Pattern2454 V2907 (freeze (shen.t*-assume Pattern Assume V2907 (freeze (cut Throwcontrol V2907 (freeze (shen.th* Pattern A Assume V2907 (freeze (cut Throwcontrol V2907 (freeze (shen.t*-patterns Patterns B Hyp V2906 V2907 V2908)))))))))))))))) (do (shen.unbindv V2470 V2907) Result)))) false)))) (if (shen.pvar? V2469) (let Pattern (shen.newpv V2907) (let A (shen.newpv V2907) (do (shen.bindv V2469 (cons Pattern (cons : (cons A ()))) V2907) (let Result (let Hyp (tl V2468) (let Assume (shen.newpv V2907) (do (shen.incinfs) (unify! A A2455 V2907 (freeze (unify! Pattern Pattern2454 V2907 (freeze (shen.t*-assume Pattern Assume V2907 (freeze (cut Throwcontrol V2907 (freeze (shen.th* Pattern A Assume V2907 (freeze (cut Throwcontrol V2907 (freeze (shen.t*-patterns Patterns B Hyp V2906 V2907 V2908)))))))))))))))) (do (shen.unbindv V2469 V2907) Result))))) false))) (if (shen.pvar? V2468) (let Pattern (shen.newpv V2907) (let A (shen.newpv V2907) (let Hyp (shen.newpv V2907) (do (shen.bindv V2468 (cons (cons Pattern (cons : (cons A ()))) Hyp) V2907) (let Result (let Assume (shen.newpv V2907) (do (shen.incinfs) (unify! A A2455 V2907 (freeze (unify! Pattern Pattern2454 V2907 (freeze (shen.t*-assume Pattern Assume V2907 (freeze (cut Throwcontrol V2907 (freeze (shen.th* Pattern A Assume V2907 (freeze (cut Throwcontrol V2907 (freeze (shen.t*-patterns Patterns B Hyp V2906 V2907 V2908))))))))))))))) (do (shen.unbindv V2468 V2907) Result)))))) false))) false))) false)) false)) false))) false)))) false)) Case)))))

(defun shen.t*-assume (V2909 V2910 V2911 V2912) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2451 (shen.lazyderef V2909 V2911) (if (cons? V2451) (let X (hd V2451) (let Y (tl V2451) (let A1 (shen.newpv V2911) (let A2 (shen.newpv V2911) (do (shen.incinfs) (cut Throwcontrol V2911 (freeze (shen.t*-assume X A1 V2911 (freeze (shen.t*-assume Y A2 V2911 (freeze (bind V2910 (append (shen.lazyderef A1 V2911) (shen.lazyderef A2 V2911)) V2911 V2912)))))))))))) false)) (if (= Case false) (let Case (let A (shen.newpv V2911) (do (shen.incinfs) (fwhen (shen.placeholder? (shen.lazyderef V2909 V2911)) V2911 (freeze (bind V2910 (cons (cons (shen.lazyderef V2909 V2911) (cons : (cons (shen.lazyderef A V2911) ()))) ()) V2911 V2912))))) (if (= Case false) (let V2452 (shen.lazyderef V2910 V2911) (if (= () V2452) (do (shen.incinfs) (thaw V2912)) (if (shen.pvar? V2452) (do (shen.bindv V2452 () V2911) (let Result (do (shen.incinfs) (thaw V2912)) (do (shen.unbindv V2452 V2911) Result))) false))) Case)) Case)))))

(defun shen.conc (V2913 V2914 V2915 V2916 V2917) (let Case (let V2447 (shen.lazyderef V2913 V2916) (if (= () V2447) (do (shen.incinfs) (bind V2915 (shen.lazyderef V2914 V2916) V2916 V2917)) false)) (if (= Case false) (let V2448 (shen.lazyderef V2913 V2916) (if (cons? V2448) (let X (hd V2448) (let Y (tl V2448) (let Z (shen.newpv V2916) (do (shen.incinfs) (bind V2915 (cons (shen.lazyderef X V2916) (shen.lazyderef Z V2916)) V2916 (freeze (shen.conc Y V2914 Z V2916 V2917))))))) false)) Case)))

(defun shen.findallhelp (V2918 V2919 V2920 V2921 V2922 V2923) (let Case (do (shen.incinfs) (call V2919 V2922 (freeze (shen.remember V2921 V2918 V2922 (freeze (fwhen false V2922 V2923)))))) (if (= Case false) (do (shen.incinfs) (bind V2920 (value (shen.lazyderef V2921 V2922)) V2922 V2923)) Case)))

(defun shen.remember (V2924 V2925 V2926 V2927) (let B (shen.newpv V2926) (do (shen.incinfs) (bind B (set (shen.deref V2924 V2926) (cons (shen.deref V2925 V2926) (value (shen.deref V2924 V2926)))) V2926 V2927))))

(defun findall (V2928 V2929 V2930 V2931 V2932) (let B (shen.newpv V2931) (let A (shen.newpv V2931) (do (shen.incinfs) (bind A (gensym shen.a) V2931 (freeze (bind B (set (shen.lazyderef A V2931) ()) V2931 (freeze (shen.findallhelp V2928 V2929 V2930 A V2931 V2932)))))))))

(defun shen.t*-defcc (V2933 V2934 V2935 V2936 V2937) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let V2420 (shen.lazyderef V2933 V2936) (if (cons? V2420) (let V2421 (shen.lazyderef (hd V2420) V2936) (if (= defcc V2421) (let V2422 (shen.lazyderef (tl V2420) V2936) (if (cons? V2422) (let F (hd V2422) (let V2423 (shen.lazyderef (tl V2422) V2936) (if (cons? V2423) (let V2424 (shen.lazyderef (hd V2423) V2936) (if (= { V2424) (let V2425 (shen.lazyderef (tl V2423) V2936) (if (cons? V2425) (let V2426 (shen.lazyderef (hd V2425) V2936) (if (cons? V2426) (let V2427 (shen.lazyderef (hd V2426) V2936) (if (= list V2427) (let V2428 (shen.lazyderef (tl V2426) V2936) (if (cons? V2428) (let A (hd V2428) (let V2429 (shen.lazyderef (tl V2428) V2936) (if (= () V2429) (let V2430 (shen.lazyderef (tl V2425) V2936) (if (cons? V2430) (let V2431 (shen.lazyderef (hd V2430) V2936) (if (= ==> V2431) (let V2432 (shen.lazyderef (tl V2430) V2936) (if (cons? V2432) (let B (hd V2432) (let V2433 (shen.lazyderef (tl V2432) V2936) (if (cons? V2433) (let V2434 (shen.lazyderef (hd V2433) V2936) (if (= } V2434) (let Rest (tl V2433) (let Rest& (shen.newpv V2936) (let Rest&& (shen.newpv V2936) (let Rules (shen.newpv V2936) (let ListA&& (shen.newpv V2936) (let B&& (shen.newpv V2936) (let Sig (shen.newpv V2936) (let Declare (shen.newpv V2936) (do (shen.incinfs) (bind Sig (shen.placeholders (cons (cons list (cons (shen.lazyderef A V2936) ())) (cons ==> (cons (shen.lazyderef B V2936) ()))) (shen.extract_vars (cons (cons list (cons (shen.lazyderef A V2936) ())) (cons ==> (cons (shen.lazyderef B V2936) ()))))) V2936 (freeze (bind ListA&& (hd (shen.lazyderef Sig V2936)) V2936 (freeze (bind B&& (hd (tl (tl (shen.lazyderef Sig V2936)))) V2936 (freeze (bind Rest& (shen.plug-wildcards (shen.lazyderef Rest V2936)) V2936 (freeze (bind Rest&& (shen.placeholders (shen.lazyderef Rest& V2936) (shen.extract_vars (shen.lazyderef Rest& V2936))) V2936 (freeze (shen.get-rules Rules Rest&& V2936 (freeze (cut Throwcontrol V2936 (freeze (shen.tc-rules F Rules ListA&& B&& (cons (cons F (cons : (cons Sig ()))) V2935) 1 V2936 (freeze (unify V2934 (cons (cons list (cons A ())) (cons ==> (cons B ()))) V2936 (freeze (bind Declare (declare (shen.lazyderef F V2936) (cons (cons list (cons (shen.lazyderef A V2936) ())) (cons ==> (cons (shen.lazyderef B V2936) ())))) V2936 V2937)))))))))))))))))))))))))))) false)) false))) false)) false)) false)) false))) false)) false)) false)) false)) false)) false))) false)) false)) false)))))

(defun shen.plug-wildcards (V2938) (cond ((cons? V2938) (map shen.plug-wildcards V2938)) ((= V2938 _) (gensym (intern "X"))) (true V2938)))

(defun shen.get-rules (V2939 V2940 V2941 V2942) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2413 (shen.lazyderef V2939 V2941) (if (= () V2413) (let V2414 (shen.lazyderef V2940 V2941) (if (= () V2414) (do (shen.incinfs) (cut Throwcontrol V2941 V2942)) false)) (if (shen.pvar? V2413) (do (shen.bindv V2413 () V2941) (let Result (let V2415 (shen.lazyderef V2940 V2941) (if (= () V2415) (do (shen.incinfs) (cut Throwcontrol V2941 V2942)) false)) (do (shen.unbindv V2413 V2941) Result))) false))) (if (= Case false) (let V2416 (shen.lazyderef V2939 V2941) (if (cons? V2416) (let Rule (hd V2416) (let Rules (tl V2416) (let Other (shen.newpv V2941) (do (shen.incinfs) (shen.first-rule V2940 Rule Other V2941 (freeze (cut Throwcontrol V2941 (freeze (shen.get-rules Rules Other V2941 V2942))))))))) (if (shen.pvar? V2416) (let Rule (shen.newpv V2941) (let Rules (shen.newpv V2941) (do (shen.bindv V2416 (cons Rule Rules) V2941) (let Result (let Other (shen.newpv V2941) (do (shen.incinfs) (shen.first-rule V2940 Rule Other V2941 (freeze (cut Throwcontrol V2941 (freeze (shen.get-rules Rules Other V2941 V2942))))))) (do (shen.unbindv V2416 V2941) Result))))) false))) Case)))))

(defun shen.first-rule (V2943 V2944 V2945 V2946 V2947) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2406 (shen.lazyderef V2943 V2946) (if (cons? V2406) (let V2407 (shen.lazyderef (hd V2406) V2946) (if (= ; V2407) (let Other2401 (tl V2406) (let V2408 (shen.lazyderef V2944 V2946) (if (= () V2408) (do (shen.incinfs) (unify! V2945 Other2401 V2946 (freeze (cut Throwcontrol V2946 V2947)))) (if (shen.pvar? V2408) (do (shen.bindv V2408 () V2946) (let Result (do (shen.incinfs) (unify! V2945 Other2401 V2946 (freeze (cut Throwcontrol V2946 V2947)))) (do (shen.unbindv V2408 V2946) Result))) false)))) false)) false)) (if (= Case false) (let V2409 (shen.lazyderef V2943 V2946) (if (cons? V2409) (let X2402 (hd V2409) (let Rest (tl V2409) (let V2410 (shen.lazyderef V2944 V2946) (if (cons? V2410) (let X (hd V2410) (let Rule (tl V2410) (do (shen.incinfs) (unify! X X2402 V2946 (freeze (shen.first-rule Rest Rule V2945 V2946 V2947)))))) (if (shen.pvar? V2410) (let X (shen.newpv V2946) (let Rule (shen.newpv V2946) (do (shen.bindv V2410 (cons X Rule) V2946) (let Result (do (shen.incinfs) (unify! X X2402 V2946 (freeze (shen.first-rule Rest Rule V2945 V2946 V2947)))) (do (shen.unbindv V2410 V2946) Result))))) false))))) false)) Case)))))

(defun shen.tc-rules (V2948 V2949 V2950 V2951 V2952 V2953 V2954 V2955) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2395 (shen.lazyderef V2949 V2954) (if (= () V2395) (do (shen.incinfs) (thaw V2955)) false)) (if (= Case false) (let V2396 (shen.lazyderef V2949 V2954) (if (cons? V2396) (let Rule (hd V2396) (let Rules (tl V2396) (let V2397 (shen.lazyderef V2950 V2954) (if (cons? V2397) (let V2398 (shen.lazyderef (hd V2397) V2954) (if (= list V2398) (let V2399 (shen.lazyderef (tl V2397) V2954) (if (cons? V2399) (let A (hd V2399) (let V2400 (shen.lazyderef (tl V2399) V2954) (if (= () V2400) (let M (shen.newpv V2954) (do (shen.incinfs) (shen.tc-rule V2948 Rule A V2951 V2952 V2953 V2954 (freeze (bind M (+ (shen.deref V2953 V2954) 1) V2954 (freeze (cut Throwcontrol V2954 (freeze (shen.tc-rules V2948 Rules (cons list (cons A ())) V2951 V2952 M V2954 V2955))))))))) false))) false)) false)) false)))) false)) Case)))))

(defun shen.tc-rule (V2956 V2957 V2958 V2959 V2960 V2961 V2962 V2963) (let Case (do (shen.incinfs) (shen.check-defcc-rule V2957 V2958 V2959 V2960 V2962 V2963)) (if (= Case false) (let Err (shen.newpv V2962) (do (shen.incinfs) (bind Err (simple-error (cn "type error in rule " (shen.app (shen.lazyderef V2961 V2962) (cn " of " (shen.app (shen.lazyderef V2956 V2962) "" shen.a)) shen.a))) V2962 V2963))) Case)))

(defun shen.check-defcc-rule (V2964 V2965 V2966 V2967 V2968 V2969) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Syntax (shen.newpv V2968) (let Semantics (shen.newpv V2968) (let SynHyps (shen.newpv V2968) (do (shen.incinfs) (shen.get-syntax+semantics Syntax Semantics V2964 V2968 (freeze (cut Throwcontrol V2968 (freeze (shen.syntax-hyps Syntax V2967 SynHyps V2965 V2968 (freeze (cut Throwcontrol V2968 (freeze (shen.syntax-check Syntax V2965 SynHyps V2968 (freeze (cut Throwcontrol V2968 (freeze (shen.semantics-check Semantics V2966 SynHyps V2968 V2969))))))))))))))))))))

(defun shen.syntax-hyps (V2970 V2971 V2972 V2973 V2974 V2975) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2366 (shen.lazyderef V2970 V2974) (if (= () V2366) (do (shen.incinfs) (unify! V2972 V2971 V2974 V2975)) false)) (if (= Case false) (let Case (let V2367 (shen.lazyderef V2970 V2974) (if (cons? V2367) (let V2368 (shen.lazyderef (hd V2367) V2974) (if (cons? V2368) (let X (hd V2368) (let Y (tl V2368) (let Z (tl V2367) (let W (shen.newpv V2974) (do (shen.incinfs) (cut Throwcontrol V2974 (freeze (shen.conc (cons X Y) Z W V2974 (freeze (cut Throwcontrol V2974 (freeze (shen.syntax-hyps W V2971 V2972 V2973 V2974 V2975)))))))))))) false)) false)) (if (= Case false) (let Case (let V2369 (shen.lazyderef V2970 V2974) (if (cons? V2369) (let X2360 (hd V2369) (let Y (tl V2369) (let V2370 (shen.lazyderef V2972 V2974) (if (cons? V2370) (let V2371 (shen.lazyderef (hd V2370) V2974) (if (cons? V2371) (let X (hd V2371) (let V2372 (shen.lazyderef (tl V2371) V2974) (if (cons? V2372) (let V2373 (shen.lazyderef (hd V2372) V2974) (if (= : V2373) (let V2374 (shen.lazyderef (tl V2372) V2974) (if (cons? V2374) (let A2361 (hd V2374) (let V2375 (shen.lazyderef (tl V2374) V2974) (if (= () V2375) (let SynHyps (tl V2370) (do (shen.incinfs) (unify! V2973 A2361 V2974 (freeze (unify! X X2360 V2974 (freeze (fwhen (shen.placeholder? (shen.deref X V2974)) V2974 (freeze (cut Throwcontrol V2974 (freeze (shen.syntax-hyps Y V2971 SynHyps V2973 V2974 V2975))))))))))) (if (shen.pvar? V2375) (do (shen.bindv V2375 () V2974) (let Result (let SynHyps (tl V2370) (do (shen.incinfs) (unify! V2973 A2361 V2974 (freeze (unify! X X2360 V2974 (freeze (fwhen (shen.placeholder? (shen.deref X V2974)) V2974 (freeze (cut Throwcontrol V2974 (freeze (shen.syntax-hyps Y V2971 SynHyps V2973 V2974 V2975))))))))))) (do (shen.unbindv V2375 V2974) Result))) false)))) (if (shen.pvar? V2374) (let A2361 (shen.newpv V2974) (do (shen.bindv V2374 (cons A2361 ()) V2974) (let Result (let SynHyps (tl V2370) (do (shen.incinfs) (unify! V2973 A2361 V2974 (freeze (unify! X X2360 V2974 (freeze (fwhen (shen.placeholder? (shen.deref X V2974)) V2974 (freeze (cut Throwcontrol V2974 (freeze (shen.syntax-hyps Y V2971 SynHyps V2973 V2974 V2975))))))))))) (do (shen.unbindv V2374 V2974) Result)))) false))) (if (shen.pvar? V2373) (do (shen.bindv V2373 : V2974) (let Result (let V2376 (shen.lazyderef (tl V2372) V2974) (if (cons? V2376) (let A2361 (hd V2376) (let V2377 (shen.lazyderef (tl V2376) V2974) (if (= () V2377) (let SynHyps (tl V2370) (do (shen.incinfs) (unify! V2973 A2361 V2974 (freeze (unify! X X2360 V2974 (freeze (fwhen (shen.placeholder? (shen.deref X V2974)) V2974 (freeze (cut Throwcontrol V2974 (freeze (shen.syntax-hyps Y V2971 SynHyps V2973 V2974 V2975))))))))))) (if (shen.pvar? V2377) (do (shen.bindv V2377 () V2974) (let Result (let SynHyps (tl V2370) (do (shen.incinfs) (unify! V2973 A2361 V2974 (freeze (unify! X X2360 V2974 (freeze (fwhen (shen.placeholder? (shen.deref X V2974)) V2974 (freeze (cut Throwcontrol V2974 (freeze (shen.syntax-hyps Y V2971 SynHyps V2973 V2974 V2975))))))))))) (do (shen.unbindv V2377 V2974) Result))) false)))) (if (shen.pvar? V2376) (let A2361 (shen.newpv V2974) (do (shen.bindv V2376 (cons A2361 ()) V2974) (let Result (let SynHyps (tl V2370) (do (shen.incinfs) (unify! V2973 A2361 V2974 (freeze (unify! X X2360 V2974 (freeze (fwhen (shen.placeholder? (shen.deref X V2974)) V2974 (freeze (cut Throwcontrol V2974 (freeze (shen.syntax-hyps Y V2971 SynHyps V2973 V2974 V2975))))))))))) (do (shen.unbindv V2376 V2974) Result)))) false))) (do (shen.unbindv V2373 V2974) Result))) false))) (if (shen.pvar? V2372) (let A2361 (shen.newpv V2974) (do (shen.bindv V2372 (cons : (cons A2361 ())) V2974) (let Result (let SynHyps (tl V2370) (do (shen.incinfs) (unify! V2973 A2361 V2974 (freeze (unify! X X2360 V2974 (freeze (fwhen (shen.placeholder? (shen.deref X V2974)) V2974 (freeze (cut Throwcontrol V2974 (freeze (shen.syntax-hyps Y V2971 SynHyps V2973 V2974 V2975))))))))))) (do (shen.unbindv V2372 V2974) Result)))) false)))) (if (shen.pvar? V2371) (let X (shen.newpv V2974) (let A2361 (shen.newpv V2974) (do (shen.bindv V2371 (cons X (cons : (cons A2361 ()))) V2974) (let Result (let SynHyps (tl V2370) (do (shen.incinfs) (unify! V2973 A2361 V2974 (freeze (unify! X X2360 V2974 (freeze (fwhen (shen.placeholder? (shen.deref X V2974)) V2974 (freeze (cut Throwcontrol V2974 (freeze (shen.syntax-hyps Y V2971 SynHyps V2973 V2974 V2975))))))))))) (do (shen.unbindv V2371 V2974) Result))))) false))) (if (shen.pvar? V2370) (let X (shen.newpv V2974) (let A2361 (shen.newpv V2974) (let SynHyps (shen.newpv V2974) (do (shen.bindv V2370 (cons (cons X (cons : (cons A2361 ()))) SynHyps) V2974) (let Result (do (shen.incinfs) (unify! V2973 A2361 V2974 (freeze (unify! X X2360 V2974 (freeze (fwhen (shen.placeholder? (shen.deref X V2974)) V2974 (freeze (cut Throwcontrol V2974 (freeze (shen.syntax-hyps Y V2971 SynHyps V2973 V2974 V2975)))))))))) (do (shen.unbindv V2370 V2974) Result)))))) false))))) false)) (if (= Case false) (let V2378 (shen.lazyderef V2970 V2974) (if (cons? V2378) (let Y (tl V2378) (do (shen.incinfs) (shen.syntax-hyps Y V2971 V2972 V2973 V2974 V2975))) false)) Case)) Case)) Case)))))

(defun shen.get-syntax+semantics (V2976 V2977 V2978 V2979 V2980) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2332 (shen.lazyderef V2976 V2979) (if (= () V2332) (let V2333 (shen.lazyderef V2978 V2979) (if (cons? V2333) (let V2334 (shen.lazyderef (hd V2333) V2979) (if (= := V2334) (let V2335 (shen.lazyderef (tl V2333) V2979) (if (cons? V2335) (let Semantics (hd V2335) (let V2336 (shen.lazyderef (tl V2335) V2979) (if (= () V2336) (do (shen.incinfs) (cut Throwcontrol V2979 (freeze (bind V2977 (shen.lazyderef Semantics V2979) V2979 V2980)))) false))) false)) false)) false)) (if (shen.pvar? V2332) (do (shen.bindv V2332 () V2979) (let Result (let V2337 (shen.lazyderef V2978 V2979) (if (cons? V2337) (let V2338 (shen.lazyderef (hd V2337) V2979) (if (= := V2338) (let V2339 (shen.lazyderef (tl V2337) V2979) (if (cons? V2339) (let Semantics (hd V2339) (let V2340 (shen.lazyderef (tl V2339) V2979) (if (= () V2340) (do (shen.incinfs) (cut Throwcontrol V2979 (freeze (bind V2977 (shen.lazyderef Semantics V2979) V2979 V2980)))) false))) false)) false)) false)) (do (shen.unbindv V2332 V2979) Result))) false))) (if (= Case false) (let Case (let V2341 (shen.lazyderef V2976 V2979) (if (= () V2341) (let V2342 (shen.lazyderef V2978 V2979) (if (cons? V2342) (let V2343 (shen.lazyderef (hd V2342) V2979) (if (= := V2343) (let V2344 (shen.lazyderef (tl V2342) V2979) (if (cons? V2344) (let Semantics (hd V2344) (let V2345 (shen.lazyderef (tl V2344) V2979) (if (cons? V2345) (let V2346 (shen.lazyderef (hd V2345) V2979) (if (= where V2346) (let V2347 (shen.lazyderef (tl V2345) V2979) (if (cons? V2347) (let G (hd V2347) (let V2348 (shen.lazyderef (tl V2347) V2979) (if (= () V2348) (do (shen.incinfs) (cut Throwcontrol V2979 (freeze (bind V2977 (cons where (cons (shen.lazyderef G V2979) (cons (shen.lazyderef Semantics V2979) ()))) V2979 V2980)))) false))) false)) false)) false))) false)) false)) false)) (if (shen.pvar? V2341) (do (shen.bindv V2341 () V2979) (let Result (let V2349 (shen.lazyderef V2978 V2979) (if (cons? V2349) (let V2350 (shen.lazyderef (hd V2349) V2979) (if (= := V2350) (let V2351 (shen.lazyderef (tl V2349) V2979) (if (cons? V2351) (let Semantics (hd V2351) (let V2352 (shen.lazyderef (tl V2351) V2979) (if (cons? V2352) (let V2353 (shen.lazyderef (hd V2352) V2979) (if (= where V2353) (let V2354 (shen.lazyderef (tl V2352) V2979) (if (cons? V2354) (let G (hd V2354) (let V2355 (shen.lazyderef (tl V2354) V2979) (if (= () V2355) (do (shen.incinfs) (cut Throwcontrol V2979 (freeze (bind V2977 (cons where (cons (shen.lazyderef G V2979) (cons (shen.lazyderef Semantics V2979) ()))) V2979 V2980)))) false))) false)) false)) false))) false)) false)) false)) (do (shen.unbindv V2341 V2979) Result))) false))) (if (= Case false) (let V2356 (shen.lazyderef V2976 V2979) (if (cons? V2356) (let X2328 (hd V2356) (let Syntax (tl V2356) (let V2357 (shen.lazyderef V2978 V2979) (if (cons? V2357) (let X (hd V2357) (let Rule (tl V2357) (do (shen.incinfs) (unify! X X2328 V2979 (freeze (shen.get-syntax+semantics Syntax V2977 Rule V2979 V2980)))))) false)))) (if (shen.pvar? V2356) (let X2328 (shen.newpv V2979) (let Syntax (shen.newpv V2979) (do (shen.bindv V2356 (cons X2328 Syntax) V2979) (let Result (let V2358 (shen.lazyderef V2978 V2979) (if (cons? V2358) (let X (hd V2358) (let Rule (tl V2358) (do (shen.incinfs) (unify! X X2328 V2979 (freeze (shen.get-syntax+semantics Syntax V2977 Rule V2979 V2980)))))) false)) (do (shen.unbindv V2356 V2979) Result))))) false))) Case)) Case)))))

(defun shen.syntax-check (V2981 V2982 V2983 V2984 V2985) (let Throwcontrol (shen.catchpoint) (shen.cutpoint Throwcontrol (let Case (let V2325 (shen.lazyderef V2981 V2984) (if (= () V2325) (do (shen.incinfs) (thaw V2985)) false)) (if (= Case false) (let Case (let V2326 (shen.lazyderef V2981 V2984) (if (cons? V2326) (let X (hd V2326) (let Syntax (tl V2326) (let C (shen.newpv V2984) (let X&& (shen.newpv V2984) (let B (shen.newpv V2984) (do (shen.incinfs) (fwhen (shen.grammar_symbol? (shen.lazyderef X V2984)) V2984 (freeze (cut Throwcontrol V2984 (freeze (shen.t* (cons X (cons : (cons (cons (cons list (cons B ())) (cons ==> (cons C ()))) ()))) V2983 V2984 (freeze (cut Throwcontrol V2984 (freeze (bind X&& (concat && (shen.lazyderef X V2984)) V2984 (freeze (cut Throwcontrol V2984 (freeze (shen.t* (cons X&& (cons : (cons (cons list (cons V2982 ())) ()))) (cons (cons X&& (cons : (cons (cons list (cons B ())) ()))) V2983) V2984 (freeze (cut Throwcontrol V2984 (freeze (shen.syntax-check Syntax V2982 V2983 V2984 V2985))))))))))))))))))))))) false)) (if (= Case false) (let V2327 (shen.lazyderef V2981 V2984) (if (cons? V2327) (let X (hd V2327) (let Syntax (tl V2327) (do (shen.incinfs) (shen.t* (cons X (cons : (cons V2982 ()))) V2983 V2984 (freeze (cut Throwcontrol V2984 (freeze (shen.syntax-check Syntax V2982 V2983 V2984 V2985)))))))) false)) Case)) Case)))))

(defun shen.semantics-check (V2986 V2987 V2988 V2989 V2990) (let Semantics* (shen.newpv V2989) (do (shen.incinfs) (bind Semantics* (shen.curry (shen.rename-semantics (shen.deref V2986 V2989))) V2989 (freeze (shen.t* (cons Semantics* (cons : (cons V2987 ()))) V2988 V2989 V2990))))))

(defun shen.rename-semantics (V2991) (cond ((cons? V2991) (cons (shen.rename-semantics (hd V2991)) (shen.rename-semantics (tl V2991)))) ((shen.grammar_symbol? V2991) (cons shen.<-sem (cons V2991 ()))) (true V2991)))



