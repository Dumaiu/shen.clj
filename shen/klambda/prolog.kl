"**********************************************************************************
*                           The License						                                      *
* 										                                                                  *
* The user is free to produce commercial applications with the software, to 	          *
* distribute these applications in source or binary  form, and to charge monies         *
* for them as he sees fit and in concordance with the laws of the land subject 	        *
* to the following license.							                                                *
*										                                                                    * 
* 1. The license applies to all the software and all derived software and 	            *
*    must appear on such.							                                                  *
*										                                                                    *
* 2. It is illegal to distribute the software without this license attached	            *
*    to it and use of the software implies agreement with the license as such.          *
*    It is illegal for anyone who is not the copyright holder to tamper with 	          *
*    or change the license.							                                                *
*										                                                                    *
* 3. Neither the names of Lambda Associates or the copyright holder may be used         *
*    to endorse or promote products built using the software without specific 	        *
*    prior written permission from the copyright holder.		                            *
*										                                                                    *
* 4. That possession of this license does not confer on the copyright holder 	          *
*    any special contractual obligation towards the user. That in no event 	            * 
*    shall the copyright holder be liable for any direct, indirect, incidental,        *   
*    special, exemplary or consequential damages (including but not limited             *
*    to procurement of substitute goods or services, loss of use, data, 	              * 
*    interruption), however caused and on any theory of liability, whether in	          * 
*    contract, strict liability or tort (including negligence) arising in any         	*
*    way out of the use of the software, even if advised of the possibility of         	*
*    such damage.						                                                        		* 
*										                                                                    *
* 5. It is permitted for the user to change the software, for the purpose of 	          *
*    improving performance, correcting an error, or porting to a new platform, 	        *
*    and distribute the derived version of Shen provided the resulting program 	        *
*    conforms in all respects to the Shen standard and is issued under that             * 
*    title. The user must make it clear with his distribution that he/she is 	          *
*    the author of the changes and what these changes are and why. 		                  *
*										                                                                    *
* 6. Derived versions of this software in whatever form are subject to the same         *
*    restrictions. In particular it is not permitted to make derived copies of          *
*    this software which do not conform to the Shen standard or appear under a          *
*    different title.								                                                    *
*										                                                                    *
*    It is permitted to distribute versions of Shen which incorporate libraries,        *
*    graphics or other facilities which are not part of the Shen standard.	            *
*										                                                                    *
* For an explication of this license see www.shenlanguage.org/license.htm which         *
* explains this license in full.                                                        *
*				 						                                                                    *
*****************************************************************************************
"(defun shen.<defprolog> (V899) (let Result (let Parse_shen.<predicate*> (shen.<predicate*> V899) (if (not (= (fail) Parse_shen.<predicate*>)) (let Parse_shen.<clauses*> (shen.<clauses*> Parse_shen.<predicate*>) (if (not (= (fail) Parse_shen.<clauses*>)) (shen.pair (hd Parse_shen.<clauses*>) (hd (shen.prolog->shen (map (lambda Parse_X (shen.insert-predicate (shen.hdtl Parse_shen.<predicate*>) Parse_X)) (shen.hdtl Parse_shen.<clauses*>))))) (fail))) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.prolog-error (V906 V907) (cond ((and (cons? V907) (and (cons? (tl V907)) (= () (tl (tl V907))))) (simple-error (cn "prolog syntax error in " (shen.app V906 (cn " here:

 " (shen.app (shen.next-50 50 (hd V907)) "
" shen.a)) shen.a)))) (true (simple-error (cn "prolog syntax error in " (shen.app V906 "
" shen.a))))))

(defun shen.next-50 (V912 V913) (cond ((= () V913) "") ((= 0 V912) "") ((cons? V913) (cn (shen.decons-string (hd V913)) (shen.next-50 (- V912 1) (tl V913)))) (true (shen.sys-error shen.next-50))))

(defun shen.decons-string (V914) (cond ((and (cons? V914) (and (= cons (hd V914)) (and (cons? (tl V914)) (and (cons? (tl (tl V914))) (= () (tl (tl (tl V914)))))))) (shen.app (shen.eval-cons V914) " " shen.s)) (true (shen.app V914 " " shen.r))))

(defun shen.insert-predicate (V915 V916) (cond ((and (cons? V916) (and (cons? (tl V916)) (= () (tl (tl V916))))) (cons (cons V915 (hd V916)) (cons :- (tl V916)))) (true (shen.sys-error shen.insert-predicate))))

(defun shen.<predicate*> (V921) (let Result (if (cons? (hd V921)) (let Parse_X (hd (hd V921)) (shen.pair (hd (shen.pair (tl (hd V921)) (shen.hdtl V921))) Parse_X)) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.<clauses*> (V926) (let Result (let Parse_shen.<clause*> (shen.<clause*> V926) (if (not (= (fail) Parse_shen.<clause*>)) (let Parse_shen.<clauses*> (shen.<clauses*> Parse_shen.<clause*>) (if (not (= (fail) Parse_shen.<clauses*>)) (shen.pair (hd Parse_shen.<clauses*>) (cons (shen.hdtl Parse_shen.<clause*>) (shen.hdtl Parse_shen.<clauses*>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_<e> (<e> V926) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) (append (shen.hdtl Parse_<e>) ())) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<clause*> (V931) (let Result (let Parse_shen.<head*> (shen.<head*> V931) (if (not (= (fail) Parse_shen.<head*>)) (if (and (cons? (hd Parse_shen.<head*>)) (= <-- (hd (hd Parse_shen.<head*>)))) (let Parse_shen.<body*> (shen.<body*> (shen.pair (tl (hd Parse_shen.<head*>)) (shen.hdtl Parse_shen.<head*>))) (if (not (= (fail) Parse_shen.<body*>)) (let Parse_shen.<end*> (shen.<end*> Parse_shen.<body*>) (if (not (= (fail) Parse_shen.<end*>)) (shen.pair (hd Parse_shen.<end*>) (cons (shen.hdtl Parse_shen.<head*>) (cons (shen.hdtl Parse_shen.<body*>) ()))) (fail))) (fail))) (fail)) (fail))) (if (= Result (fail)) (fail) Result)))

(defun shen.<head*> (V936) (let Result (let Parse_shen.<term*> (shen.<term*> V936) (if (not (= (fail) Parse_shen.<term*>)) (let Parse_shen.<head*> (shen.<head*> Parse_shen.<term*>) (if (not (= (fail) Parse_shen.<head*>)) (shen.pair (hd Parse_shen.<head*>) (cons (shen.hdtl Parse_shen.<term*>) (shen.hdtl Parse_shen.<head*>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_<e> (<e> V936) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) (append (shen.hdtl Parse_<e>) ())) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<term*> (V941) (let Result (if (cons? (hd V941)) (let Parse_X (hd (hd V941)) (if (and (not (= <-- Parse_X)) (shen.legitimate-term? Parse_X)) (shen.pair (hd (shen.pair (tl (hd V941)) (shen.hdtl V941))) (shen.eval-cons Parse_X)) (fail))) (fail)) (if (= Result (fail)) (fail) Result)))

(defun shen.legitimate-term? (V946) (cond ((and (cons? V946) (and (= cons (hd V946)) (and (cons? (tl V946)) (and (cons? (tl (tl V946))) (= () (tl (tl (tl V946)))))))) (and (shen.legitimate-term? (hd (tl V946))) (shen.legitimate-term? (hd (tl (tl V946)))))) ((and (cons? V946) (and (= mode (hd V946)) (and (cons? (tl V946)) (and (cons? (tl (tl V946))) (and (= + (hd (tl (tl V946)))) (= () (tl (tl (tl V946))))))))) (shen.legitimate-term? (hd (tl V946)))) ((and (cons? V946) (and (= mode (hd V946)) (and (cons? (tl V946)) (and (cons? (tl (tl V946))) (and (= - (hd (tl (tl V946)))) (= () (tl (tl (tl V946))))))))) (shen.legitimate-term? (hd (tl V946)))) ((cons? V946) false) (true true)))

(defun shen.eval-cons (V947) (cond ((and (cons? V947) (and (= cons (hd V947)) (and (cons? (tl V947)) (and (cons? (tl (tl V947))) (= () (tl (tl (tl V947)))))))) (cons (shen.eval-cons (hd (tl V947))) (shen.eval-cons (hd (tl (tl V947)))))) ((and (cons? V947) (and (= mode (hd V947)) (and (cons? (tl V947)) (and (cons? (tl (tl V947))) (= () (tl (tl (tl V947)))))))) (cons mode (cons (shen.eval-cons (hd (tl V947))) (tl (tl V947))))) (true V947)))

(defun shen.<body*> (V952) (let Result (let Parse_shen.<literal*> (shen.<literal*> V952) (if (not (= (fail) Parse_shen.<literal*>)) (let Parse_shen.<body*> (shen.<body*> Parse_shen.<literal*>) (if (not (= (fail) Parse_shen.<body*>)) (shen.pair (hd Parse_shen.<body*>) (cons (shen.hdtl Parse_shen.<literal*>) (shen.hdtl Parse_shen.<body*>))) (fail))) (fail))) (if (= Result (fail)) (let Result (let Parse_<e> (<e> V952) (if (not (= (fail) Parse_<e>)) (shen.pair (hd Parse_<e>) (append (shen.hdtl Parse_<e>) ())) (fail))) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<literal*> (V957) (let Result (if (and (cons? (hd V957)) (= ! (hd (hd V957)))) (shen.pair (hd (shen.pair (tl (hd V957)) (shen.hdtl V957))) (cons cut (cons (intern "Throwcontrol") ()))) (fail)) (if (= Result (fail)) (let Result (if (cons? (hd V957)) (let Parse_X (hd (hd V957)) (if (cons? Parse_X) (shen.pair (hd (shen.pair (tl (hd V957)) (shen.hdtl V957))) Parse_X) (fail))) (fail)) (if (= Result (fail)) (fail) Result)) Result)))

(defun shen.<end*> (V962) (let Result (if (cons? (hd V962)) (let Parse_X (hd (hd V962)) (if (= Parse_X ;) (shen.pair (hd (shen.pair (tl (hd V962)) (shen.hdtl V962))) Parse_X) (fail))) (fail)) (if (= Result (fail)) (fail) Result)))

(defun cut (V963 V964 V965) (let Result (thaw V965) (if (= Result false) V963 Result)))

(defun shen.insert_modes (V966) (cond ((and (cons? V966) (and (= mode (hd V966)) (and (cons? (tl V966)) (and (cons? (tl (tl V966))) (= () (tl (tl (tl V966)))))))) V966) ((= () V966) ()) ((cons? V966) (cons (cons mode (cons (hd V966) (cons + ()))) (cons mode (cons (shen.insert_modes (tl V966)) (cons - ()))))) (true V966)))

(defun shen.s-prolog (V967) (map (lambda V893 (eval V893)) (shen.prolog->shen V967)))

(defun shen.prolog->shen (V968) (map shen.compile_prolog_procedure (shen.group_clauses (map shen.s-prolog_clause (mapcan shen.head_abstraction V968)))))

(defun shen.s-prolog_clause (V969) (cond ((and (cons? V969) (and (cons? (tl V969)) (and (= :- (hd (tl V969))) (and (cons? (tl (tl V969))) (= () (tl (tl (tl V969)))))))) (cons (hd V969) (cons :- (cons (map shen.s-prolog_literal (hd (tl (tl V969)))) ())))) (true (shen.sys-error shen.s-prolog_clause))))

(defun shen.head_abstraction (V970) (cond ((and (cons? V970) (and (cons? (tl V970)) (and (= :- (hd (tl V970))) (and (cons? (tl (tl V970))) (and (= () (tl (tl (tl V970)))) (< (shen.complexity_head (hd V970)) (value shen.*maxcomplexity*))))))) (cons V970 ())) ((and (cons? V970) (and (cons? (hd V970)) (and (cons? (tl V970)) (and (= :- (hd (tl V970))) (and (cons? (tl (tl V970))) (= () (tl (tl (tl V970))))))))) (let Terms (map (lambda Y (gensym V)) (tl (hd V970))) (let XTerms (shen.rcons_form (shen.remove_modes (tl (hd V970)))) (let Literal (cons unify (cons (shen.cons_form Terms) (cons XTerms ()))) (let Clause (cons (cons (hd (hd V970)) Terms) (cons :- (cons (cons Literal (hd (tl (tl V970)))) ()))) (cons Clause ())))))) (true (shen.sys-error shen.head_abstraction))))

(defun shen.complexity_head (V975) (cond ((cons? V975) (shen.product (map shen.complexity (tl V975)))) (true (shen.sys-error shen.complexity_head))))

(defun shen.complexity (V983) (cond ((and (cons? V983) (and (= mode (hd V983)) (and (cons? (tl V983)) (and (cons? (hd (tl V983))) (and (= mode (hd (hd (tl V983)))) (and (cons? (tl (hd (tl V983)))) (and (cons? (tl (tl (hd (tl V983))))) (and (= () (tl (tl (tl (hd (tl V983)))))) (and (cons? (tl (tl V983))) (= () (tl (tl (tl V983))))))))))))) (shen.complexity (hd (tl V983)))) ((and (cons? V983) (and (= mode (hd V983)) (and (cons? (tl V983)) (and (cons? (hd (tl V983))) (and (cons? (tl (tl V983))) (and (= + (hd (tl (tl V983)))) (= () (tl (tl (tl V983)))))))))) (* 2 (* (shen.complexity (cons mode (cons (hd (hd (tl V983))) (tl (tl V983))))) (shen.complexity (cons mode (cons (tl (hd (tl V983))) (tl (tl V983)))))))) ((and (cons? V983) (and (= mode (hd V983)) (and (cons? (tl V983)) (and (cons? (hd (tl V983))) (and (cons? (tl (tl V983))) (and (= - (hd (tl (tl V983)))) (= () (tl (tl (tl V983)))))))))) (* (shen.complexity (cons mode (cons (hd (hd (tl V983))) (tl (tl V983))))) (shen.complexity (cons mode (cons (tl (hd (tl V983))) (tl (tl V983))))))) ((and (cons? V983) (and (= mode (hd V983)) (and (cons? (tl V983)) (and (cons? (tl (tl V983))) (and (= () (tl (tl (tl V983)))) (variable? (hd (tl V983)))))))) 1) ((and (cons? V983) (and (= mode (hd V983)) (and (cons? (tl V983)) (and (cons? (tl (tl V983))) (and (= + (hd (tl (tl V983)))) (= () (tl (tl (tl V983))))))))) 2) ((and (cons? V983) (and (= mode (hd V983)) (and (cons? (tl V983)) (and (cons? (tl (tl V983))) (and (= - (hd (tl (tl V983)))) (= () (tl (tl (tl V983))))))))) 1) (true (shen.complexity (cons mode (cons V983 (cons + ())))))))

(defun shen.product (V984) (cond ((= () V984) 1) ((cons? V984) (* (hd V984) (shen.product (tl V984)))) (true (shen.sys-error shen.product))))

(defun shen.s-prolog_literal (V985) (cond ((and (cons? V985) (and (= is (hd V985)) (and (cons? (tl V985)) (and (cons? (tl (tl V985))) (= () (tl (tl (tl V985)))))))) (cons bind (cons (hd (tl V985)) (cons (shen.insert_deref (hd (tl (tl V985)))) ())))) ((and (cons? V985) (and (= when (hd V985)) (and (cons? (tl V985)) (= () (tl (tl V985)))))) (cons fwhen (cons (shen.insert_deref (hd (tl V985))) ()))) ((and (cons? V985) (and (= bind (hd V985)) (and (cons? (tl V985)) (and (cons? (tl (tl V985))) (= () (tl (tl (tl V985)))))))) (cons bind (cons (hd (tl V985)) (cons (shen.insert_lazyderef (hd (tl (tl V985)))) ())))) ((and (cons? V985) (and (= fwhen (hd V985)) (and (cons? (tl V985)) (= () (tl (tl V985)))))) (cons fwhen (cons (shen.insert_lazyderef (hd (tl V985))) ()))) ((cons? V985) (cons (shen.m_prolog_to_s-prolog_predicate (hd V985)) (tl V985))) (true (shen.sys-error shen.s-prolog_literal))))

(defun shen.insert_deref (V986) (cond ((variable? V986) (cons shen.deref (cons V986 (cons ProcessN ())))) ((cons? V986) (cons (shen.insert_deref (hd V986)) (shen.insert_deref (tl V986)))) (true V986)))

(defun shen.insert_lazyderef (V987) (cond ((variable? V987) (cons shen.lazyderef (cons V987 (cons ProcessN ())))) ((cons? V987) (cons (shen.insert_lazyderef (hd V987)) (shen.insert_lazyderef (tl V987)))) (true V987)))

(defun shen.m_prolog_to_s-prolog_predicate (V988) (cond ((= = V988) unify) ((= =! V988) unify!) ((= == V988) identical) (true V988)))

(defun shen.group_clauses (V989) (cond ((= () V989) ()) ((cons? V989) (let Group (shen.collect (lambda X (shen.same_predicate? (hd V989) X)) V989) (let Rest (difference V989 Group) (cons Group (shen.group_clauses Rest))))) (true (shen.sys-error shen.group_clauses))))

(defun shen.collect (V992 V993) (cond ((= () V993) ()) ((cons? V993) (if (V992 (hd V993)) (cons (hd V993) (shen.collect V992 (tl V993))) (shen.collect V992 (tl V993)))) (true (shen.sys-error shen.collect))))

(defun shen.same_predicate? (V1010 V1011) (cond ((and (cons? V1010) (and (cons? (hd V1010)) (and (cons? V1011) (cons? (hd V1011))))) (= (hd (hd V1010)) (hd (hd V1011)))) (true (shen.sys-error shen.same_predicate?))))

(defun shen.compile_prolog_procedure (V1012) (let F (shen.procedure_name V1012) (let Shen (shen.clauses-to-shen F V1012) Shen)))

(defun shen.procedure_name (V1025) (cond ((and (cons? V1025) (and (cons? (hd V1025)) (cons? (hd (hd V1025))))) (hd (hd (hd V1025)))) (true (shen.sys-error shen.procedure_name))))

(defun shen.clauses-to-shen (V1026 V1027) (let Linear (map shen.linearise-clause V1027) (let Arity (shen.prolog-aritycheck V1026 (map (lambda V894 (head V894)) V1027)) (let Parameters (shen.parameters Arity) (let AUM_instructions (map (lambda X (shen.aum X Parameters)) Linear) (let Code (shen.catch-cut (shen.nest-disjunct (map shen.aum_to_shen AUM_instructions))) (let ShenDef (cons define (cons V1026 (append Parameters (append (cons ProcessN (cons Continuation ())) (cons -> (cons Code ())))))) ShenDef)))))))

(defun shen.catch-cut (V1028) (cond ((not (shen.occurs? cut V1028)) V1028) (true (cons let (cons Throwcontrol (cons (cons shen.catchpoint ()) (cons (cons shen.cutpoint (cons Throwcontrol (cons V1028 ()))) ())))))))

(defun shen.catchpoint () (set shen.*catch* (+ 1 (value shen.*catch*))))

(defun shen.cutpoint (V1033 V1034) (cond ((= V1034 V1033) false) (true V1034)))

(defun shen.nest-disjunct (V1036) (cond ((and (cons? V1036) (= () (tl V1036))) (hd V1036)) ((cons? V1036) (shen.lisp-or (hd V1036) (shen.nest-disjunct (tl V1036)))) (true (shen.sys-error shen.nest-disjunct))))

(defun shen.lisp-or (V1037 V1038) (cons let (cons Case (cons V1037 (cons (cons if (cons (cons = (cons Case (cons false ()))) (cons V1038 (cons Case ())))) ())))))

(defun shen.prolog-aritycheck (V1041 V1042) (cond ((and (cons? V1042) (= () (tl V1042))) (- (length (hd V1042)) 1)) ((and (cons? V1042) (cons? (tl V1042))) (if (= (length (hd V1042)) (length (hd (tl V1042)))) (shen.prolog-aritycheck V1041 (tl V1042)) (simple-error (cn "arity error in prolog procedure " (shen.app (cons V1041 ()) "
" shen.a))))) (true (shen.sys-error shen.prolog-aritycheck))))

(defun shen.linearise-clause (V1043) (cond ((and (cons? V1043) (and (cons? (tl V1043)) (and (= :- (hd (tl V1043))) (and (cons? (tl (tl V1043))) (= () (tl (tl (tl V1043)))))))) (let Linear (shen.linearise (cons (hd V1043) (tl (tl V1043)))) (shen.clause_form Linear))) (true (shen.sys-error shen.linearise-clause))))

(defun shen.clause_form (V1044) (cond ((and (cons? V1044) (and (cons? (tl V1044)) (= () (tl (tl V1044))))) (cons (shen.explicit_modes (hd V1044)) (cons :- (cons (shen.cf_help (hd (tl V1044))) ())))) (true (shen.sys-error shen.clause_form))))

(defun shen.explicit_modes (V1045) (cond ((cons? V1045) (cons (hd V1045) (map shen.em_help (tl V1045)))) (true (shen.sys-error shen.explicit_modes))))

(defun shen.em_help (V1046) (cond ((and (cons? V1046) (and (= mode (hd V1046)) (and (cons? (tl V1046)) (and (cons? (tl (tl V1046))) (= () (tl (tl (tl V1046)))))))) V1046) (true (cons mode (cons V1046 (cons + ()))))))

(defun shen.cf_help (V1047) (cond ((and (cons? V1047) (and (= where (hd V1047)) (and (cons? (tl V1047)) (and (cons? (hd (tl V1047))) (and (= = (hd (hd (tl V1047)))) (and (cons? (tl (hd (tl V1047)))) (and (cons? (tl (tl (hd (tl V1047))))) (and (= () (tl (tl (tl (hd (tl V1047)))))) (and (cons? (tl (tl V1047))) (= () (tl (tl (tl V1047))))))))))))) (cons (cons (if (value shen.*occurs*) unify! unify) (tl (hd (tl V1047)))) (shen.cf_help (hd (tl (tl V1047)))))) (true V1047)))

(defun occurs-check (V1052) (cond ((= + V1052) (set shen.*occurs* true)) ((= - V1052) (set shen.*occurs* false)) (true (simple-error "occurs-check expects + or -
"))))

(defun shen.aum (V1053 V1054) (cond ((and (cons? V1053) (and (cons? (hd V1053)) (and (cons? (tl V1053)) (and (= :- (hd (tl V1053))) (and (cons? (tl (tl V1053))) (= () (tl (tl (tl V1053))))))))) (let MuApplication (shen.make_mu_application (cons shen.mu (cons (tl (hd V1053)) (cons (shen.continuation_call (tl (hd V1053)) (hd (tl (tl V1053)))) ()))) V1054) (shen.mu_reduction MuApplication +))) (true (shen.sys-error shen.aum))))

(defun shen.continuation_call (V1055 V1056) (let VTerms (cons ProcessN (shen.extract_vars V1055)) (let VBody (shen.extract_vars V1056) (let Free (remove Throwcontrol (difference VBody VTerms)) (shen.cc_help Free V1056)))))

(defun remove (V1057 V1058) (shen.remove-h V1057 V1058 ()))

(defun shen.remove-h (V1061 V1062 V1063) (cond ((= () V1062) (reverse V1063)) ((and (cons? V1062) (= (hd V1062) V1061)) (shen.remove-h (hd V1062) (tl V1062) V1063)) ((cons? V1062) (shen.remove-h V1061 (tl V1062) (cons (hd V1062) V1063))) (true (shen.sys-error shen.remove-h))))

(defun shen.cc_help (V1065 V1066) (cond ((and (= () V1065) (= () V1066)) (cons shen.pop (cons shen.the (cons shen.stack ())))) ((= () V1066) (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons V1065 (cons and (cons shen.then (cons (cons shen.pop (cons shen.the (cons shen.stack ()))) ()))))))))) ((= () V1065) (cons call (cons shen.the (cons shen.continuation (cons V1066 ()))))) (true (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons V1065 (cons and (cons shen.then (cons (cons call (cons shen.the (cons shen.continuation (cons V1066 ())))) ())))))))))))

(defun shen.make_mu_application (V1067 V1068) (cond ((and (cons? V1067) (and (= shen.mu (hd V1067)) (and (cons? (tl V1067)) (and (= () (hd (tl V1067))) (and (cons? (tl (tl V1067))) (and (= () (tl (tl (tl V1067)))) (= () V1068))))))) (hd (tl (tl V1067)))) ((and (cons? V1067) (and (= shen.mu (hd V1067)) (and (cons? (tl V1067)) (and (cons? (hd (tl V1067))) (and (cons? (tl (tl V1067))) (and (= () (tl (tl (tl V1067)))) (cons? V1068))))))) (cons (cons shen.mu (cons (hd (hd (tl V1067))) (cons (shen.make_mu_application (cons shen.mu (cons (tl (hd (tl V1067))) (tl (tl V1067)))) (tl V1068)) ()))) (cons (hd V1068) ()))) (true (shen.sys-error shen.make_mu_application))))

(defun shen.mu_reduction (V1075 V1076) (cond ((and (cons? V1075) (and (cons? (hd V1075)) (and (= shen.mu (hd (hd V1075))) (and (cons? (tl (hd V1075))) (and (cons? (hd (tl (hd V1075)))) (and (= mode (hd (hd (tl (hd V1075))))) (and (cons? (tl (hd (tl (hd V1075))))) (and (cons? (tl (tl (hd (tl (hd V1075)))))) (and (= () (tl (tl (tl (hd (tl (hd V1075))))))) (and (cons? (tl (tl (hd V1075)))) (and (= () (tl (tl (tl (hd V1075))))) (and (cons? (tl V1075)) (= () (tl (tl V1075))))))))))))))) (shen.mu_reduction (cons (cons shen.mu (cons (hd (tl (hd (tl (hd V1075))))) (tl (tl (hd V1075))))) (tl V1075)) (hd (tl (tl (hd (tl (hd V1075)))))))) ((and (cons? V1075) (and (cons? (hd V1075)) (and (= shen.mu (hd (hd V1075))) (and (cons? (tl (hd V1075))) (and (cons? (tl (tl (hd V1075)))) (and (= () (tl (tl (tl (hd V1075))))) (and (cons? (tl V1075)) (and (= () (tl (tl V1075))) (= _ (hd (tl (hd V1075)))))))))))) (shen.mu_reduction (hd (tl (tl (hd V1075)))) V1076)) ((and (cons? V1075) (and (cons? (hd V1075)) (and (= shen.mu (hd (hd V1075))) (and (cons? (tl (hd V1075))) (and (cons? (tl (tl (hd V1075)))) (and (= () (tl (tl (tl (hd V1075))))) (and (cons? (tl V1075)) (and (= () (tl (tl V1075))) (shen.ephemeral_variable? (hd (tl (hd V1075))) (hd (tl V1075))))))))))) (subst (hd (tl V1075)) (hd (tl (hd V1075))) (shen.mu_reduction (hd (tl (tl (hd V1075)))) V1076))) ((and (cons? V1075) (and (cons? (hd V1075)) (and (= shen.mu (hd (hd V1075))) (and (cons? (tl (hd V1075))) (and (cons? (tl (tl (hd V1075)))) (and (= () (tl (tl (tl (hd V1075))))) (and (cons? (tl V1075)) (and (= () (tl (tl V1075))) (variable? (hd (tl (hd V1075)))))))))))) (cons let (cons (hd (tl (hd V1075))) (cons shen.be (cons (hd (tl V1075)) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V1075)))) V1076) ()))))))) ((and (cons? V1075) (and (cons? (hd V1075)) (and (= shen.mu (hd (hd V1075))) (and (cons? (tl (hd V1075))) (and (cons? (tl (tl (hd V1075)))) (and (= () (tl (tl (tl (hd V1075))))) (and (cons? (tl V1075)) (and (= () (tl (tl V1075))) (and (= - V1076) (shen.prolog_constant? (hd (tl (hd V1075))))))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V1075))))) (cons in (cons (cons if (cons (cons Z (cons is (cons identical (cons shen.to (cons (hd (tl (hd V1075))) ()))))) (cons shen.then (cons (shen.mu_reduction (hd (tl (tl (hd V1075)))) -) (cons shen.else (cons shen.failed! ())))))) ())))))))) ((and (cons? V1075) (and (cons? (hd V1075)) (and (= shen.mu (hd (hd V1075))) (and (cons? (tl (hd V1075))) (and (cons? (tl (tl (hd V1075)))) (and (= () (tl (tl (tl (hd V1075))))) (and (cons? (tl V1075)) (and (= () (tl (tl V1075))) (and (= + V1076) (shen.prolog_constant? (hd (tl (hd V1075))))))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V1075))))) (cons in (cons (cons if (cons (cons Z (cons is (cons identical (cons shen.to (cons (hd (tl (hd V1075))) ()))))) (cons shen.then (cons (shen.mu_reduction (hd (tl (tl (hd V1075)))) +) (cons shen.else (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.variable ())))) (cons shen.then (cons (cons bind (cons Z (cons shen.to (cons (hd (tl (hd V1075))) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V1075)))) +) ())))))) (cons shen.else (cons shen.failed! ())))))) ())))))) ())))))))) ((and (cons? V1075) (and (cons? (hd V1075)) (and (= shen.mu (hd (hd V1075))) (and (cons? (tl (hd V1075))) (and (cons? (hd (tl (hd V1075)))) (and (cons? (tl (tl (hd V1075)))) (and (= () (tl (tl (tl (hd V1075))))) (and (cons? (tl V1075)) (and (= () (tl (tl V1075))) (= - V1076)))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V1075))))) (cons in (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.non-empty (cons list ()))))) (cons shen.then (cons (shen.mu_reduction (cons (cons shen.mu (cons (hd (hd (tl (hd V1075)))) (cons (cons (cons shen.mu (cons (tl (hd (tl (hd V1075)))) (tl (tl (hd V1075))))) (cons (cons shen.the (cons tail (cons shen.of (cons Z ())))) ())) ()))) (cons (cons shen.the (cons head (cons shen.of (cons Z ())))) ())) -) (cons shen.else (cons shen.failed! ())))))) ())))))))) ((and (cons? V1075) (and (cons? (hd V1075)) (and (= shen.mu (hd (hd V1075))) (and (cons? (tl (hd V1075))) (and (cons? (hd (tl (hd V1075)))) (and (cons? (tl (tl (hd V1075)))) (and (= () (tl (tl (tl (hd V1075))))) (and (cons? (tl V1075)) (and (= () (tl (tl V1075))) (= + V1076)))))))))) (let Z (gensym V) (cons let (cons Z (cons shen.be (cons (cons shen.the (cons shen.result (cons shen.of (cons shen.dereferencing (tl V1075))))) (cons in (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.non-empty (cons list ()))))) (cons shen.then (cons (shen.mu_reduction (cons (cons shen.mu (cons (hd (hd (tl (hd V1075)))) (cons (cons (cons shen.mu (cons (tl (hd (tl (hd V1075)))) (tl (tl (hd V1075))))) (cons (cons shen.the (cons tail (cons shen.of (cons Z ())))) ())) ()))) (cons (cons shen.the (cons head (cons shen.of (cons Z ())))) ())) +) (cons shen.else (cons (cons if (cons (cons Z (cons is (cons shen.a (cons shen.variable ())))) (cons shen.then (cons (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons (shen.extract_vars (hd (tl (hd V1075)))) (cons and (cons shen.then (cons (cons bind (cons Z (cons shen.to (cons (shen.rcons_form (shen.remove_modes (hd (tl (hd V1075))))) (cons in (cons (shen.mu_reduction (hd (tl (tl (hd V1075)))) +) ())))))) ())))))))) (cons shen.else (cons shen.failed! ())))))) ())))))) ())))))))) (true V1075)))

(defun shen.rcons_form (V1077) (cond ((cons? V1077) (cons cons (cons (shen.rcons_form (hd V1077)) (cons (shen.rcons_form (tl V1077)) ())))) (true V1077)))

(defun shen.remove_modes (V1078) (cond ((and (cons? V1078) (and (= mode (hd V1078)) (and (cons? (tl V1078)) (and (cons? (tl (tl V1078))) (and (= + (hd (tl (tl V1078)))) (= () (tl (tl (tl V1078))))))))) (shen.remove_modes (hd (tl V1078)))) ((and (cons? V1078) (and (= mode (hd V1078)) (and (cons? (tl V1078)) (and (cons? (tl (tl V1078))) (and (= - (hd (tl (tl V1078)))) (= () (tl (tl (tl V1078))))))))) (shen.remove_modes (hd (tl V1078)))) ((cons? V1078) (cons (shen.remove_modes (hd V1078)) (shen.remove_modes (tl V1078)))) (true V1078)))

(defun shen.ephemeral_variable? (V1079 V1080) (and (variable? V1079) (variable? V1080)))

(defun shen.prolog_constant? (V1089) (cond ((cons? V1089) false) (true true)))

(defun shen.aum_to_shen (V1090) (cond ((and (cons? V1090) (and (= let (hd V1090)) (and (cons? (tl V1090)) (and (cons? (tl (tl V1090))) (and (= shen.be (hd (tl (tl V1090)))) (and (cons? (tl (tl (tl V1090)))) (and (cons? (tl (tl (tl (tl V1090))))) (and (= in (hd (tl (tl (tl (tl V1090)))))) (and (cons? (tl (tl (tl (tl (tl V1090)))))) (= () (tl (tl (tl (tl (tl (tl V1090)))))))))))))))) (cons let (cons (hd (tl V1090)) (cons (shen.aum_to_shen (hd (tl (tl (tl V1090))))) (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V1090))))))) ()))))) ((and (cons? V1090) (and (= shen.the (hd V1090)) (and (cons? (tl V1090)) (and (= shen.result (hd (tl V1090))) (and (cons? (tl (tl V1090))) (and (= shen.of (hd (tl (tl V1090)))) (and (cons? (tl (tl (tl V1090)))) (and (= shen.dereferencing (hd (tl (tl (tl V1090))))) (and (cons? (tl (tl (tl (tl V1090))))) (= () (tl (tl (tl (tl (tl V1090))))))))))))))) (cons shen.lazyderef (cons (shen.aum_to_shen (hd (tl (tl (tl (tl V1090)))))) (cons ProcessN ())))) ((and (cons? V1090) (and (= if (hd V1090)) (and (cons? (tl V1090)) (and (cons? (tl (tl V1090))) (and (= shen.then (hd (tl (tl V1090)))) (and (cons? (tl (tl (tl V1090)))) (and (cons? (tl (tl (tl (tl V1090))))) (and (= shen.else (hd (tl (tl (tl (tl V1090)))))) (and (cons? (tl (tl (tl (tl (tl V1090)))))) (= () (tl (tl (tl (tl (tl (tl V1090)))))))))))))))) (cons if (cons (shen.aum_to_shen (hd (tl V1090))) (cons (shen.aum_to_shen (hd (tl (tl (tl V1090))))) (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V1090))))))) ()))))) ((and (cons? V1090) (and (cons? (tl V1090)) (and (= is (hd (tl V1090))) (and (cons? (tl (tl V1090))) (and (= shen.a (hd (tl (tl V1090)))) (and (cons? (tl (tl (tl V1090)))) (and (= shen.variable (hd (tl (tl (tl V1090))))) (= () (tl (tl (tl (tl V1090)))))))))))) (cons shen.pvar? (cons (hd V1090) ()))) ((and (cons? V1090) (and (cons? (tl V1090)) (and (= is (hd (tl V1090))) (and (cons? (tl (tl V1090))) (and (= shen.a (hd (tl (tl V1090)))) (and (cons? (tl (tl (tl V1090)))) (and (= shen.non-empty (hd (tl (tl (tl V1090))))) (and (cons? (tl (tl (tl (tl V1090))))) (and (= list (hd (tl (tl (tl (tl V1090)))))) (= () (tl (tl (tl (tl (tl V1090))))))))))))))) (cons cons? (cons (hd V1090) ()))) ((and (cons? V1090) (and (= shen.rename (hd V1090)) (and (cons? (tl V1090)) (and (= shen.the (hd (tl V1090))) (and (cons? (tl (tl V1090))) (and (= shen.variables (hd (tl (tl V1090)))) (and (cons? (tl (tl (tl V1090)))) (and (= in (hd (tl (tl (tl V1090))))) (and (cons? (tl (tl (tl (tl V1090))))) (and (= () (hd (tl (tl (tl (tl V1090)))))) (and (cons? (tl (tl (tl (tl (tl V1090)))))) (and (= and (hd (tl (tl (tl (tl (tl V1090))))))) (and (cons? (tl (tl (tl (tl (tl (tl V1090))))))) (and (= shen.then (hd (tl (tl (tl (tl (tl (tl V1090)))))))) (and (cons? (tl (tl (tl (tl (tl (tl (tl V1090)))))))) (= () (tl (tl (tl (tl (tl (tl (tl (tl V1090)))))))))))))))))))))))) (shen.aum_to_shen (hd (tl (tl (tl (tl (tl (tl (tl V1090)))))))))) ((and (cons? V1090) (and (= shen.rename (hd V1090)) (and (cons? (tl V1090)) (and (= shen.the (hd (tl V1090))) (and (cons? (tl (tl V1090))) (and (= shen.variables (hd (tl (tl V1090)))) (and (cons? (tl (tl (tl V1090)))) (and (= in (hd (tl (tl (tl V1090))))) (and (cons? (tl (tl (tl (tl V1090))))) (and (cons? (hd (tl (tl (tl (tl V1090)))))) (and (cons? (tl (tl (tl (tl (tl V1090)))))) (and (= and (hd (tl (tl (tl (tl (tl V1090))))))) (and (cons? (tl (tl (tl (tl (tl (tl V1090))))))) (and (= shen.then (hd (tl (tl (tl (tl (tl (tl V1090)))))))) (and (cons? (tl (tl (tl (tl (tl (tl (tl V1090)))))))) (= () (tl (tl (tl (tl (tl (tl (tl (tl V1090)))))))))))))))))))))))) (cons let (cons (hd (hd (tl (tl (tl (tl V1090)))))) (cons (cons shen.newpv (cons ProcessN ())) (cons (shen.aum_to_shen (cons shen.rename (cons shen.the (cons shen.variables (cons in (cons (tl (hd (tl (tl (tl (tl V1090)))))) (tl (tl (tl (tl (tl V1090))))))))))) ()))))) ((and (cons? V1090) (and (= bind (hd V1090)) (and (cons? (tl V1090)) (and (cons? (tl (tl V1090))) (and (= shen.to (hd (tl (tl V1090)))) (and (cons? (tl (tl (tl V1090)))) (and (cons? (tl (tl (tl (tl V1090))))) (and (= in (hd (tl (tl (tl (tl V1090)))))) (and (cons? (tl (tl (tl (tl (tl V1090)))))) (= () (tl (tl (tl (tl (tl (tl V1090)))))))))))))))) (cons do (cons (cons shen.bindv (cons (hd (tl V1090)) (cons (shen.chwild (hd (tl (tl (tl V1090))))) (cons ProcessN ())))) (cons (cons let (cons Result (cons (shen.aum_to_shen (hd (tl (tl (tl (tl (tl V1090))))))) (cons (cons do (cons (cons shen.unbindv (cons (hd (tl V1090)) (cons ProcessN ()))) (cons Result ()))) ())))) ())))) ((and (cons? V1090) (and (cons? (tl V1090)) (and (= is (hd (tl V1090))) (and (cons? (tl (tl V1090))) (and (= identical (hd (tl (tl V1090)))) (and (cons? (tl (tl (tl V1090)))) (and (= shen.to (hd (tl (tl (tl V1090))))) (and (cons? (tl (tl (tl (tl V1090))))) (= () (tl (tl (tl (tl (tl V1090)))))))))))))) (cons = (cons (hd (tl (tl (tl (tl V1090))))) (cons (hd V1090) ())))) ((= shen.failed! V1090) false) ((and (cons? V1090) (and (= shen.the (hd V1090)) (and (cons? (tl V1090)) (and (= head (hd (tl V1090))) (and (cons? (tl (tl V1090))) (and (= shen.of (hd (tl (tl V1090)))) (and (cons? (tl (tl (tl V1090)))) (= () (tl (tl (tl (tl V1090)))))))))))) (cons hd (tl (tl (tl V1090))))) ((and (cons? V1090) (and (= shen.the (hd V1090)) (and (cons? (tl V1090)) (and (= tail (hd (tl V1090))) (and (cons? (tl (tl V1090))) (and (= shen.of (hd (tl (tl V1090)))) (and (cons? (tl (tl (tl V1090)))) (= () (tl (tl (tl (tl V1090)))))))))))) (cons tl (tl (tl (tl V1090))))) ((and (cons? V1090) (and (= shen.pop (hd V1090)) (and (cons? (tl V1090)) (and (= shen.the (hd (tl V1090))) (and (cons? (tl (tl V1090))) (and (= shen.stack (hd (tl (tl V1090)))) (= () (tl (tl (tl V1090)))))))))) (cons do (cons (cons shen.incinfs ()) (cons (cons thaw (cons Continuation ())) ())))) ((and (cons? V1090) (and (= call (hd V1090)) (and (cons? (tl V1090)) (and (= shen.the (hd (tl V1090))) (and (cons? (tl (tl V1090))) (and (= shen.continuation (hd (tl (tl V1090)))) (and (cons? (tl (tl (tl V1090)))) (= () (tl (tl (tl (tl V1090)))))))))))) (cons do (cons (cons shen.incinfs ()) (cons (shen.call_the_continuation (shen.chwild (hd (tl (tl (tl V1090))))) ProcessN Continuation) ())))) (true V1090)))

(defun shen.chwild (V1091) (cond ((= V1091 _) (cons shen.newpv (cons ProcessN ()))) ((cons? V1091) (map shen.chwild V1091)) (true V1091)))

(defun shen.newpv (V1092) (let Count+1 (+ (<-address (value shen.*varcounter*) V1092) 1) (let IncVar (address-> (value shen.*varcounter*) V1092 Count+1) (let Vector (<-address (value shen.*prologvectors*) V1092) (let ResizeVectorIfNeeded (if (= Count+1 (limit Vector)) (shen.resizeprocessvector V1092 Count+1) shen.skip) (shen.mk-pvar Count+1))))))

(defun shen.resizeprocessvector (V1093 V1094) (let Vector (<-address (value shen.*prologvectors*) V1093) (let BigVector (shen.resize-vector Vector (+ V1094 V1094) shen.-null-) (address-> (value shen.*prologvectors*) V1093 BigVector))))

(defun shen.resize-vector (V1095 V1096 V1097) (let BigVector (address-> (absvector (+ 1 V1096)) 0 V1096) (shen.copy-vector V1095 BigVector (limit V1095) V1096 V1097)))

(defun shen.copy-vector (V1098 V1099 V1100 V1101 V1102) (shen.copy-vector-stage-2 (+ 1 V1100) (+ V1101 1) V1102 (shen.copy-vector-stage-1 1 V1098 V1099 (+ 1 V1100))))

(defun shen.copy-vector-stage-1 (V1105 V1106 V1107 V1108) (cond ((= V1108 V1105) V1107) (true (shen.copy-vector-stage-1 (+ 1 V1105) V1106 (address-> V1107 V1105 (<-address V1106 V1105)) V1108))))

(defun shen.copy-vector-stage-2 (V1112 V1113 V1114 V1115) (cond ((= V1113 V1112) V1115) (true (shen.copy-vector-stage-2 (+ V1112 1) V1113 V1114 (address-> V1115 V1112 V1114)))))

(defun shen.mk-pvar (V1117) (address-> (address-> (absvector 2) 0 shen.pvar) 1 V1117))

(defun shen.pvar? (V1118) (and (absvector? V1118) (= (<-address V1118 0) shen.pvar)))

(defun shen.bindv (V1119 V1120 V1121) (let Vector (<-address (value shen.*prologvectors*) V1121) (address-> Vector (<-address V1119 1) V1120)))

(defun shen.unbindv (V1122 V1123) (let Vector (<-address (value shen.*prologvectors*) V1123) (address-> Vector (<-address V1122 1) shen.-null-)))

(defun shen.incinfs () (set shen.*infs* (+ 1 (value shen.*infs*))))

(defun shen.call_the_continuation (V1124 V1125 V1126) (cond ((and (cons? V1124) (and (cons? (hd V1124)) (= () (tl V1124)))) (cons (hd (hd V1124)) (append (tl (hd V1124)) (cons V1125 (cons V1126 ()))))) ((and (cons? V1124) (cons? (hd V1124))) (let NewContinuation (shen.newcontinuation (tl V1124) V1125 V1126) (cons (hd (hd V1124)) (append (tl (hd V1124)) (cons V1125 (cons NewContinuation ())))))) (true (shen.sys-error shen.call_the_continuation))))

(defun shen.newcontinuation (V1127 V1128 V1129) (cond ((= () V1127) V1129) ((and (cons? V1127) (cons? (hd V1127))) (cons freeze (cons (cons (hd (hd V1127)) (append (tl (hd V1127)) (cons V1128 (cons (shen.newcontinuation (tl V1127) V1128 V1129) ())))) ()))) (true (shen.sys-error shen.newcontinuation))))

(defun return (V1134 V1135 V1136) (shen.deref V1134 V1135))

(defun shen.measure&return (V1141 V1142 V1143) (do (pr (shen.app (value shen.*infs*) " inferences
" shen.a) (stoutput)) (shen.deref V1141 V1142)))

(defun unify (V1144 V1145 V1146 V1147) (shen.lzy= (shen.lazyderef V1144 V1146) (shen.lazyderef V1145 V1146) V1146 V1147))

(defun shen.lzy= (V1164 V1165 V1166 V1167) (cond ((= V1165 V1164) (thaw V1167)) ((shen.pvar? V1164) (bind V1164 V1165 V1166 V1167)) ((shen.pvar? V1165) (bind V1165 V1164 V1166 V1167)) ((and (cons? V1164) (cons? V1165)) (shen.lzy= (shen.lazyderef (hd V1164) V1166) (shen.lazyderef (hd V1165) V1166) V1166 (freeze (shen.lzy= (shen.lazyderef (tl V1164) V1166) (shen.lazyderef (tl V1165) V1166) V1166 V1167)))) (true false)))

(defun shen.deref (V1169 V1170) (cond ((cons? V1169) (cons (shen.deref (hd V1169) V1170) (shen.deref (tl V1169) V1170))) (true (if (shen.pvar? V1169) (let Value (shen.valvector V1169 V1170) (if (= Value shen.-null-) V1169 (shen.deref Value V1170))) V1169))))

(defun shen.lazyderef (V1171 V1172) (if (shen.pvar? V1171) (let Value (shen.valvector V1171 V1172) (if (= Value shen.-null-) V1171 (shen.lazyderef Value V1172))) V1171))

(defun shen.valvector (V1173 V1174) (<-address (<-address (value shen.*prologvectors*) V1174) (<-address V1173 1)))

(defun unify! (V1175 V1176 V1177 V1178) (shen.lzy=! (shen.lazyderef V1175 V1177) (shen.lazyderef V1176 V1177) V1177 V1178))

(defun shen.lzy=! (V1195 V1196 V1197 V1198) (cond ((= V1196 V1195) (thaw V1198)) ((and (shen.pvar? V1195) (not (shen.occurs? V1195 (shen.deref V1196 V1197)))) (bind V1195 V1196 V1197 V1198)) ((and (shen.pvar? V1196) (not (shen.occurs? V1196 (shen.deref V1195 V1197)))) (bind V1196 V1195 V1197 V1198)) ((and (cons? V1195) (cons? V1196)) (shen.lzy=! (shen.lazyderef (hd V1195) V1197) (shen.lazyderef (hd V1196) V1197) V1197 (freeze (shen.lzy=! (shen.lazyderef (tl V1195) V1197) (shen.lazyderef (tl V1196) V1197) V1197 V1198)))) (true false)))

(defun shen.occurs? (V1208 V1209) (cond ((= V1209 V1208) true) ((cons? V1209) (or (shen.occurs? V1208 (hd V1209)) (shen.occurs? V1208 (tl V1209)))) (true false)))

(defun identical (V1211 V1212 V1213 V1214) (shen.lzy== (shen.lazyderef V1211 V1213) (shen.lazyderef V1212 V1213) V1213 V1214))

(defun shen.lzy== (V1231 V1232 V1233 V1234) (cond ((= V1232 V1231) (thaw V1234)) ((and (cons? V1231) (cons? V1232)) (shen.lzy== (shen.lazyderef (hd V1231) V1233) (shen.lazyderef (hd V1232) V1233) V1233 (freeze (shen.lzy== (tl V1231) (tl V1232) V1233 V1234)))) (true false)))

(defun shen.pvar (V1236) (cn "Var" (shen.app (<-address V1236 1) "" shen.a)))

(defun bind (V1237 V1238 V1239 V1240) (do (shen.bindv V1237 V1238 V1239) (let Result (thaw V1240) (do (shen.unbindv V1237 V1239) Result))))

(defun fwhen (V1255 V1256 V1257) (cond ((= true V1255) (thaw V1257)) ((= false V1255) false) (true (simple-error (cn "fwhen expects a boolean: not " (shen.app V1255 "%" shen.s))))))

(defun call (V1270 V1271 V1272) (cond ((cons? V1270) (shen.call-help (shen.m_prolog_to_s-prolog_predicate (shen.lazyderef (hd V1270) V1271)) (tl V1270) V1271 V1272)) (true false)))

(defun shen.call-help (V1273 V1274 V1275 V1276) (cond ((= () V1274) (V1273 V1275 V1276)) ((cons? V1274) (shen.call-help (V1273 (hd V1274)) (tl V1274) V1275 V1276)) (true (shen.sys-error shen.call-help))))

(defun shen.intprolog (V1277) (cond ((and (cons? V1277) (cons? (hd V1277))) (let ProcessN (shen.start-new-prolog-process) (shen.intprolog-help (hd (hd V1277)) (shen.insert-prolog-variables (cons (tl (hd V1277)) (cons (tl V1277) ())) ProcessN) ProcessN))) (true (shen.sys-error shen.intprolog))))

(defun shen.intprolog-help (V1278 V1279 V1280) (cond ((and (cons? V1279) (and (cons? (tl V1279)) (= () (tl (tl V1279))))) (shen.intprolog-help-help V1278 (hd V1279) (hd (tl V1279)) V1280)) (true (shen.sys-error shen.intprolog-help))))

(defun shen.intprolog-help-help (V1281 V1282 V1283 V1284) (cond ((= () V1282) (V1281 V1284 (freeze (shen.call-rest V1283 V1284)))) ((cons? V1282) (shen.intprolog-help-help (V1281 (hd V1282)) (tl V1282) V1283 V1284)) (true (shen.sys-error shen.intprolog-help-help))))

(defun shen.call-rest (V1287 V1288) (cond ((= () V1287) true) ((and (cons? V1287) (and (cons? (hd V1287)) (cons? (tl (hd V1287))))) (shen.call-rest (cons (cons ((hd (hd V1287)) (hd (tl (hd V1287)))) (tl (tl (hd V1287)))) (tl V1287)) V1288)) ((and (cons? V1287) (and (cons? (hd V1287)) (= () (tl (hd V1287))))) ((hd (hd V1287)) V1288 (freeze (shen.call-rest (tl V1287) V1288)))) (true (shen.sys-error shen.call-rest))))

(defun shen.start-new-prolog-process () (let IncrementProcessCounter (set shen.*process-counter* (+ 1 (value shen.*process-counter*))) (shen.initialise-prolog IncrementProcessCounter)))

(defun shen.insert-prolog-variables (V1289 V1290) (shen.insert-prolog-variables-help V1289 (shen.flatten V1289) V1290))

(defun shen.insert-prolog-variables-help (V1295 V1296 V1297) (cond ((= () V1296) V1295) ((and (cons? V1296) (variable? (hd V1296))) (let V (shen.newpv V1297) (let XV/Y (subst V (hd V1296) V1295) (let Z-Y (remove (hd V1296) (tl V1296)) (shen.insert-prolog-variables-help XV/Y Z-Y V1297))))) ((cons? V1296) (shen.insert-prolog-variables-help V1295 (tl V1296) V1297)) (true (shen.sys-error shen.insert-prolog-variables-help))))

(defun shen.initialise-prolog (V1298) (let Vector (address-> (value shen.*prologvectors*) V1298 (shen.fillvector (vector 10) 1 10 shen.-null-)) (let Counter (address-> (value shen.*varcounter*) V1298 1) V1298)))



